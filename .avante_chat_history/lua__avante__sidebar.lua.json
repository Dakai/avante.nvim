[{"timestamp": "2024-08-17 13:50:29", "response": "```lua\nL1: local View = require(\"avante.view\")\nL2: \nL3: local Path = require(\"plenary.path\")\nL4: local N = require(\"nui-components\")\nL5: local Renderer = require(\"nui-components.renderer\")\nL6: local diff = require(\"avante.diff\")\nL7: local config = require(\"avante.config\")\nL8: local ai_bot = require(\"avante.ai_bot\")\nL9: local api = vim.api\nL10: local fn = vim.fn\nL11: \nL12: local CODEBLOCK_KEYBINDING_NAMESPACE = api.nvim_create_namespace(\"AVANTE_CODEBLOCK_KEYBINDING\")\nL13: local PRIORITY = vim.highlight.priorities.user\nL14: \nL15: ---@class avante.Sidebar\nL16: local Sidebar = {}\nL17: \nL18: ---@class avante.SidebarState\nL19: ---@field win integer\nL20: ---@field buf integer\nL21: \nL22: ---@class avante.Sidebar\nL23: ---@field id integer\nL24: ---@field view avante.View\nL25: ---@field code avante.SidebarState\nL26: ---@field renderer NuiRenderer\nL27: \nL28: function Sidebar:new(id)\nL29:   return setmetatable({\nL30:     id = id,\nL31:     code = { buf = 0, win = 0 },\nL32:     view = View:new(),\nL33:     renderer = nil,\nL34:   }, { __index = Sidebar })\nL35: end\nL36: \nL37: function Sidebar:destroy()\nL38:   self.view = nil\nL39:   self.code = nil\nL40:   self.renderer = nil\nL41: end\nL42: \nL43: function Sidebar:reset()\nL44:   self.code = { buf = 0, win = 0 }\nL45: end\nL46: \nL47: function Sidebar:open()\nL48:   if not self.view:is_open() then\nL49:     self:intialize()\nL50:     self:render()\nL51:   else\nL52:     self:focus()\nL53:   end\nL54:   return self\nL55: end\nL56: \nL57: function Sidebar:toggle()\nL58:   if self.view:is_open() then\nL59:     self:close()\nL60:     return false\nL61:   else\nL62:     self:open()\nL63:     return true\nL64:   end\nL65: end\nL66: \nL67: function Sidebar:has_code_win()\nL68:   return self.code.win\nL69:       and self.code.buf\nL70:       and self.code.win ~= 0\nL71:       and self.code.buf ~= 0\nL72:       and api.nvim_win_is_valid(self.code.win)\nL73:       and api.nvim_buf_is_valid(self.code.buf)\nL74: end\nL75: \nL76: function Sidebar:focus_code()\nL77:   if self:has_code_win() then\nL78:     fn.win_gotoid(self.code.win)\nL79:     return true\nL80:   end\nL81:   return false\nL82: end\nL83: \nL84: function Sidebar:focus_toggle()\nL85:   if self.view:is_open() and self:has_code_win() then\nL86:     local winid = fn.win_getid()\nL87:     if winid == self.code.win then\nL88:       fn.win_gotoid(self.view.win)\nL89:     else\nL90:       fn.win_gotoid(self.code.win)\nL91:     end\nL92:     return true\nL93:   end\nL94:   return false\nL95: end\nL96: \nL97: local get_renderer_size_and_position = function()\nL98:   local renderer_width = math.ceil(vim.o.columns * 0.3)\nL99:   local renderer_height = vim.o.lines\nL100:   local renderer_position = vim.o.columns - renderer_width\nL101:   return renderer_width, renderer_height, renderer_position\nL102: end\nL103: \nL104: function Sidebar:intialize()\nL105:   self.code.win = api.nvim_get_current_win()\nL106:   self.code.buf = api.nvim_get_current_buf()\nL107: \nL108:   local split_command = \"botright vs\"\nL109:   local renderer_width, renderer_height, renderer_position = get_renderer_size_and_position()\nL110: \nL111:   self.view:setup(split_command, renderer_width)\nL112: \nL113:   local winid = fn.bufwinid(self.view.buf)\nL114:   --- setup coord\nL115:   self.renderer = Renderer.create({\nL116:     width = api.nvim_win_get_width(winid),\nL117:     height = renderer_height,\nL118:     position = renderer_position,\nL119:     relative = { type = \"win\", winid = winid },\nL120:   })\nL121: \nL122:   -- reset states when buffer is closed\nL123:   api.nvim_buf_attach(self.code.buf, false, {\nL124:     on_detach = function(_, _)\nL125:       self:reset()\nL126:     end,\nL127:   })\nL128: end\nL129: \nL130: function Sidebar:close()\nL131:   self.renderer:close()\nL132:   fn.win_gotoid(self.code.win)\nL133: end\nL134: \nL135: ---@return boolean\nL136: function Sidebar:focus()\nL137:   if self.view:is_open() then\nL138:     fn.win_gotoid(self.view.win)\nL139:     self.renderer:focus()\nL140:     return true\nL141:   end\nL142:   return false\nL143: end\nL144: \nL145: ---@param content string\nL146: ---@param jump? boolean\nL147: function Sidebar:update_content(content, jump)\nL148:   jump = jump or false\nL149: \nL150:   vim.defer_fn(function()\nL151:     api.nvim_set_option_value(\"modifiable\", true, { buf = self.view.buf })\nL152:     api.nvim_buf_set_lines(self.view.buf, 0, -1, false, vim.split(content, \"\\n\"))\nL153:     api.nvim_set_option_value(\"modifiable\", false, { buf = self.view.buf })\nL154:     api.nvim_set_option_value(\"filetype\", \"Avante\", { buf = self.view.buf })\nL155: \nL156:     -- Move to the bottom\nL157:     if jump then\nL158:       api.nvim_win_set_cursor(self.view.win, { api.nvim_buf_line_count(self.view.buf), 0 })\nL159:       api.nvim_set_current_win(self.code.win)\nL160:     else\nL161:       self.renderer:focus()\nL162:     end\nL163:   end, 0)\nL164: end\nL165: \nL166: local function parse_codeblocks(buf)\nL167:   local codeblocks = {}\nL168:   local in_codeblock = false\nL169:   local start_line = nil\nL170:   local lang = nil\nL171: \nL172:   local lines = api.nvim_buf_get_lines(buf, 0, -1, false)\nL173:   for i, line in ipairs(lines) do\nL174:     if line:match(\"^```\") then\nL175:       -- parse language\nL176:       local lang_ = line:match(\"^```(%w+)\")\nL177:       if in_codeblock and not lang_ then\nL178:         table.insert(codeblocks, { start_line = start_line, end_line = i - 1, lang = lang })\nL179:         in_codeblock = false\nL180:       elseif lang_ then\nL181:         lang = lang_\nL182:         start_line = i - 1\nL183:         in_codeblock = true\nL184:       end\nL185:     end\nL186:   end\nL187: \nL188:   return codeblocks\nL189: end\nL190: \nL191: ---@param codeblocks table<integer, any>\nL192: local function is_cursor_in_codeblock(codeblocks)\nL193:   local cursor_pos = api.nvim_win_get_cursor(0)\nL194:   local cursor_line = cursor_pos[1] - 1 -- 转换为 0-indexed 行号\nL195: \nL196:   for _, block in ipairs(codeblocks) do\nL197:     if cursor_line >= block.start_line and cursor_line <= block.end_line then\nL198:       return block\nL199:     end\nL200:   end\nL201: \nL202:   return nil\nL203: end\nL204: \nL205: local function prepend_line_number(content)\nL206:   local lines = vim.split(content, \"\\n\")\nL207:   local result = {}\nL208:   for i, line in ipairs(lines) do\nL209:     table.insert(result, \"L\" .. i .. \": \" .. line)\nL210:   end\nL211:   return table.concat(result, \"\\n\")\nL212: end\nL213: \nL214: local function extract_code_snippets(content)\nL215:   local snippets = {}\nL216:   local current_snippet = {}\nL217:   local in_code_block = false\nL218:   local lang, start_line, end_line\nL219:   local explanation = \"\"\nL220: \nL221:   for line in content:gmatch(\"[^\\r\\n]+\") do\nL222:     local start_line_str, end_line_str = line:match(\"^Replace lines: (%d+)-(%d+)\")\nL223:     if start_line_str ~= nil and end_line_str ~= nil then\nL224:       start_line = tonumber(start_line_str)\nL225:       end_line = tonumber(end_line_str)\nL226:     end\nL227:     if line:match(\"^```\") then\nL228:       if in_code_block then\nL229:         if start_line ~= nil and end_line ~= nil then\nL230:           table.insert(snippets, {\nL231:             range = { start_line, end_line },\nL232:             content = table.concat(current_snippet, \"\\n\"),\nL233:             lang = lang,\nL234:             explanation = explanation,\nL235:           })\nL236:         end\nL237:         current_snippet = {}\nL238:         start_line, end_line = nil, nil\nL239:         explanation = \"\"\nL240:         in_code_block = false\nL241:       else\nL242:         lang = line:match(\"^```(%w+)\")\nL243:         if not lang or lang == \"\" then\nL244:           lang = \"text\"\nL245:         end\nL246:         in_code_block = true\nL247:       end\nL248:     elseif in_code_block then\nL249:       table.insert(current_snippet, line)\nL250:     else\nL251:       explanation = explanation .. line .. \"\\n\"\nL252:     end\nL253:   end\nL254: \nL255:   return snippets\nL256: end\nL257: \nL258: -- Add a new function to display notifications\nL259: local function show_notification(message)\nL260:   vim.notify(message, vim.log.levels.INFO, {\nL261:     title = \"AI Assistant\",\nL262:     timeout = 3000,\nL263:   })\nL264: end\nL265: \nL266: -- Function to get the current project root directory\nL267: local function get_project_root()\nL268:   local current_file = fn.expand(\"%:p\")\nL269:   local current_dir = fn.fnamemodify(current_file, \":h\")\nL270:   local git_root = fn.systemlist(\"git -C \" .. fn.shellescape(current_dir) .. \" rev-parse --show-toplevel\")[1]\nL271:   return git_root or current_dir\nL272: end\nL273: \nL274: ---@param sidebar avante.Sidebar\nL275: local function get_chat_history_filename(sidebar)\nL276:   local code_buf_name = api.nvim_buf_get_name(sidebar.code.buf)\nL277:   local relative_path = fn.fnamemodify(code_buf_name, \":~:.\")\nL278:   -- Replace path separators with double underscores\nL279:   local path_with_separators = fn.substitute(relative_path, \"/\", \"__\", \"g\")\nL280:   -- Replace other non-alphanumeric characters with single underscores\nL281:   return fn.substitute(path_with_separators, \"[^A-Za-z0-9._]\", \"_\", \"g\")\nL282: end\nL283: \nL284: -- Function to get the chat history file path\nL285: local function get_chat_history_file(sidebar)\nL286:   local project_root = get_project_root()\nL287:   local filename = get_chat_history_filename(sidebar)\nL288:   local history_dir = Path:new(project_root, \".avante_chat_history\")\nL289:   return history_dir:joinpath(filename .. \".json\")\nL290: end\nL291: \nL292: -- Function to get current timestamp\nL293: local function get_timestamp()\nL294:   return os.date(\"%Y-%m-%d %H:%M:%S\")\nL295: end\nL296: \nL297: -- Function to load chat history\nL298: local function load_chat_history(sidebar)\nL299:   local history_file = get_chat_history_file(sidebar)\nL300:   if history_file:exists() then\nL301:     local content = history_file:read()\nL302:     return fn.json_decode(content)\nL", "requirement": "how to make the sidebar and input frame without borders?"}, {"timestamp": "2024-08-17 13:50:54", "response": "```lua\nL1: local View = require(\"avante.view\")\nL2: \nL3: local Path = require(\"plenary.path\")\nL4: local N = require(\"nui-components\")\nL5: local Renderer = require(\"nui-components.renderer\")\nL6: local diff = require(\"avante.diff\")\nL7: local config = require(\"avante.config\")\nL8: local ai_bot = require(\"avante.ai_bot\")\nL9: local api = vim.api\nL10: local fn = vim.fn\nL11: \nL12: local CODEBLOCK_KEYBINDING_NAMESPACE = api.nvim_create_namespace(\"AVANTE_CODEBLOCK_KEYBINDING\")\nL13: local PRIORITY = vim.highlight.priorities.user\nL14: \nL15: ---@class avante.Sidebar\nL16: local Sidebar = {}\nL17: \nL18: ---@class avante.SidebarState\nL19: ---@field win integer\nL20: ---@field buf integer\nL21: \nL22: ---@class avante.Sidebar\nL23: ---@field id integer\nL24: ---@field view avante.View\nL25: ---@field code avante.SidebarState\nL26: ---@field renderer NuiRenderer\nL27: \nL28: function Sidebar:new(id)\nL29:   return setmetatable({\nL30:     id = id,\nL31:     code = { buf = 0, win = 0 },\nL32:     view = View:new(),\nL33:     renderer = nil,\nL34:   }, { __index = Sidebar })\nL35: end\nL36: \nL37: function Sidebar:destroy()\nL38:   self.view = nil\nL39:   self.code = nil\nL40:   self.renderer = nil\nL41: end\nL42: \nL43: function Sidebar:reset()\nL44:   self.code = { buf = 0, win = 0 }\nL45: end\nL46: \nL47: function Sidebar:open()\nL48:   if not self.view:is_open() then\nL49:     self:intialize()\nL50:     self:render()\nL51:   else\nL52:     self:focus()\nL53:   end\nL54:   return self\nL55: end\nL56: \nL57: function Sidebar:toggle()\nL58:   if self.view:is_open() then\nL59:     self:close()\nL60:     return false\nL61:   else\nL62:     self:open()\nL63:     return true\nL64:   end\nL65: end\nL66: \nL67: function Sidebar:has_code_win()\nL68:   return self.code.win\nL69:       and self.code.buf\nL70:       and self.code.win ~= 0\nL71:       and self.code.buf ~= 0\nL72:       and api.nvim_win_is_valid(self.code.win)\nL73:       and api.nvim_buf_is_valid(self.code.buf)\nL74: end\nL75: \nL76: function Sidebar:focus_code()\nL77:   if self:has_code_win() then\nL78:     fn.win_gotoid(self.code.win)\nL79:     return true\nL80:   end\nL81:   return false\nL82: end\nL83: \nL84: function Sidebar:focus_toggle()\nL85:   if self.view:is_open() and self:has_code_win() then\nL86:     local winid = fn.win_getid()\nL87:     if winid == self.code.win then\nL88:       fn.win_gotoid(self.view.win)\nL89:     else\nL90:       fn.win_gotoid(self.code.win)\nL91:     end\nL92:     return true\nL93:   end\nL94:   return false\nL95: end\nL96: \nL97: local get_renderer_size_and_position = function()\nL98:   local renderer_width = math.ceil(vim.o.columns * 0.3)\nL99:   local renderer_height = vim.o.lines\nL100:   local renderer_position = vim.o.columns - renderer_width\nL101:   return renderer_width, renderer_height, renderer_position\nL102: end\nL103: \nL104: function Sidebar:intialize()\nL105:   self.code.win = api.nvim_get_current_win()\nL106:   self.code.buf = api.nvim_get_current_buf()\nL107: \nL108:   local split_command = \"botright vs\"\nL109:   local renderer_width, renderer_height, renderer_position = get_renderer_size_and_position()\nL110: \nL111:   self.view:setup(split_command, renderer_width)\nL112: \nL113:   local winid = fn.bufwinid(self.view.buf)\nL114:   --- setup coord\nL115:   self.renderer = Renderer.create({\nL116:     width = api.nvim_win_get_width(winid),\nL117:     height = renderer_height,\nL118:     position = renderer_position,\nL119:     relative = { type = \"win\", winid = winid },\nL120:   })\nL121: \nL122:   -- reset states when buffer is closed\nL123:   api.nvim_buf_attach(self.code.buf, false, {\nL124:     on_detach = function(_, _)\nL125:       self:reset()\nL126:     end,\nL127:   })\nL128: end\nL129: \nL130: function Sidebar:close()\nL131:   self.renderer:close()\nL132:   fn.win_gotoid(self.code.win)\nL133: end\nL134: \nL135: ---@return boolean\nL136: function Sidebar:focus()\nL137:   if self.view:is_open() then\nL138:     fn.win_gotoid(self.view.win)\nL139:     self.renderer:focus()\nL140:     return true\nL141:   end\nL142:   return false\nL143: end\nL144: \nL145: ---@param content string\nL146: ---@param jump? boolean\nL147: function Sidebar:update_content(content, jump)\nL148:   jump = jump or false\nL149: \nL150:   vim.defer_fn(function()\nL151:     api.nvim_set_option_value(\"modifiable\", true, { buf = self.view.buf })\nL152:     api.nvim_buf_set_lines(self.view.buf, 0, -1, false, vim.split(content, \"\\n\"))\nL153:     api.nvim_set_option_value(\"modifiable\", false, { buf = self.view.buf })\nL154:     api.nvim_set_option_value(\"filetype\", \"Avante\", { buf = self.view.buf })\nL155: \nL156:     -- Move to the bottom\nL157:     if jump then\nL158:       api.nvim_win_set_cursor(self.view.win, { api.nvim_buf_line_count(self.view.buf), 0 })\nL159:       api.nvim_set_current_win(self.code.win)\nL160:     else\nL161:       self.renderer:focus()\nL162:     end\nL163:   end, 0)\nL164: end\nL165: \nL166: local function parse_codeblocks(buf)\nL167:   local codeblocks = {}\nL168:   local in_codeblock = false\nL169:   local start_line = nil\nL170:   local lang = nil\nL171: \nL172:   local lines = api.nvim_buf_get_lines(buf, 0, -1, false)\nL173:   for i, line in ipairs(lines) do\nL174:     if line:match(\"^```\") then\nL175:       -- parse language\nL176:       local lang_ = line:match(\"^```(%w+)\")\nL177:       if in_codeblock and not lang_ then\nL178:         table.insert(codeblocks, { start_line = start_line, end_line = i - 1, lang = lang })\nL179:         in_codeblock = false\nL180:       elseif lang_ then\nL181:         lang = lang_\nL182:         start_line = i - 1\nL183:         in_codeblock = true\nL184:       end\nL185:     end\nL186:   end\nL187: \nL188:   return codeblocks\nL189: end\nL190: \nL191: ---@param codeblocks table<integer, any>\nL192: local function is_cursor_in_codeblock(codeblocks)\nL193:   local cursor_pos = api.nvim_win_get_cursor(0)\nL194:   local cursor_line = cursor_pos[1] - 1 -- 转换为 0-indexed 行号\nL195: \nL196:   for _, block in ipairs(codeblocks) do\nL197:     if cursor_line >= block.start_line and cursor_line <= block.end_line then\nL198:       return block\nL199:     end\nL200:   end\nL201: \nL202:   return nil\nL203: end\nL204: \nL205: local function prepend_line_number(content)\nL206:   local lines = vim.split(content, \"\\n\")\nL207:   local result = {}\nL208:   for i, line in ipairs(lines) do\nL209:     table.insert(result, \"L\" .. i .. \": \" .. line)\nL210:   end\nL211:   return table.concat(result, \"\\n\")\nL212: end\nL213: \nL214: local function extract_code_snippets(content)\nL215:   local snippets = {}\nL216:   local current_snippet = {}\nL217:   local in_code_block = false\nL218:   local lang, start_line, end_line\nL219:   local explanation = \"\"\nL220: \nL221:   for line in content:gmatch(\"[^\\r\\n]+\") do\nL222:     local start_line_str, end_line_str = line:match(\"^Replace lines: (%d+)-(%d+)\")\nL223:     if start_line_str ~= nil and end_line_str ~= nil then\nL224:       start_line = tonumber(start_line_str)\nL225:       end_line = tonumber(end_line_str)\nL226:     end\nL227:     if line:match(\"^```\") then\nL228:       if in_code_block then\nL229:         if start_line ~= nil and end_line ~= nil then\nL230:           table.insert(snippets, {\nL231:             range = { start_line, end_line },\nL232:             content = table.concat(current_snippet, \"\\n\"),\nL233:             lang = lang,\nL234:             explanation = explanation,\nL235:           })\nL236:         end\nL237:         current_snippet = {}\nL238:         start_line, end_line = nil, nil\nL239:         explanation = \"\"\nL240:         in_code_block = false\nL241:       else\nL242:         lang = line:match(\"^```(%w+)\")\nL243:         if not lang or lang == \"\" then\nL244:           lang = \"text\"\nL245:         end\nL246:         in_code_block = true\nL247:       end\nL248:     elseif in_code_block then\nL249:       table.insert(current_snippet, line)\nL250:     else\nL251:       explanation = explanation .. line .. \"\\n\"\nL252:     end\nL253:   end\nL254: \nL255:   return snippets\nL256: end\nL257: \nL258: -- Add a new function to display notifications\nL259: local function show_notification(message)\nL260:   vim.notify(message, vim.log.levels.INFO, {\nL261:     title = \"AI Assistant\",\nL262:     timeout = 3000,\nL263:   })\nL264: end\nL265: \nL266: -- Function to get the current project root directory\nL267: local function get_project_root()\nL268:   local current_file = fn.expand(\"%:p\")\nL269:   local current_dir = fn.fnamemodify(current_file, \":h\")\nL270:   local git_root = fn.systemlist(\"git -C \" .. fn.shellescape(current_dir) .. \" rev-parse --show-toplevel\")[1]\nL271:   return git_root or current_dir\nL272: end\nL273: \nL274: ---@param sidebar avante.Sidebar\nL275: local function get_chat_history_filename(sidebar)\nL276:   local code_buf_name = api.nvim_buf_get_name(sidebar.code.buf)\nL277:   local relative_path = fn.fnamemodify(code_buf_name, \":~:.\")\nL278:   -- Replace path separators with double underscores\nL279:   local path_with_separators = fn.substitute(relative_path, \"/\", \"__\", \"g\")\nL280:   -- Replace other non-alphanumeric characters with single underscores\nL281:   return fn.substitute(path_with_separators, \"[^A-Za-z0-9._]\", \"_\", \"g\")\nL282: end\nL283: \nL284: -- Function to get the chat history file path\nL285: local function get_chat_history_file(sidebar)\nL286:   local project_root = get_project_root()\nL287:   local filename = get_chat_history_filename(sidebar)\nL288:   local history_dir = Path:new(project_root, \".avante_chat_history\")\nL289:   return history_dir:joinpath(filename .. \".json\")\nL290: end\nL291: \nL292: -- Function to get current timestamp\nL293: local function get_timestamp()\nL294:   return os.date(\"%Y-%m-%d %H:%M:%S\")\nL295: end\nL296: \nL297: -- Function to load chat history\nL298: local function load_chat_history(sidebar)\nL299:   local history_file = get_chat_history_file(sidebar)\nL300:   if history_file:exists() then\nL301:     local content = history_file:read()\nL302:     return fn.json_decode(content)\nL", "requirement": "how to make the sidebar and input frame without borders?"}, {"timestamp": "2024-08-17 14:24:10", "response": "```lua\nL1: local View = require(\"avante.view\")\nL2: \nL3: local Path = require(\"plenary.path\")\nL4: local N = require(\"nui-components\")\nL5: local Renderer = require(\"nui-components.renderer\")\nL6: local diff = require(\"avante.diff\")\nL7: local config = require(\"avante.config\")\nL8: local ai_bot = require(\"avante.ai_bot\")\nL9: local api = vim.api\nL10: local fn = vim.fn\nL11: \nL12: local CODEBLOCK_KEYBINDING_NAMESPACE = api.nvim_create_namespace(\"AVANTE_CODEBLOCK_KEYBINDING\")\nL13: local PRIORITY = vim.highlight.priorities.user\nL14: \nL15: ---@class avante.Sidebar\nL16: local Sidebar = {}\nL17: \nL18: ---@class avante.SidebarState\nL19: ---@field win integer\nL20: ---@field buf integer\nL21: \nL22: ---@class avante.Sidebar\nL23: ---@field id integer\nL24: ---@field view avante.View\nL25: ---@field code avante.SidebarState\nL26: ---@field renderer NuiRenderer\nL27: \nL28: function Sidebar:new(id)\nL29:   return setmetatable({\nL30:     id = id,\nL31:     code = { buf = 0, win = 0 },\nL32:     view = View:new(),\nL33:     renderer = nil,\nL34:   }, { __index = Sidebar })\nL35: end\nL36: \nL37: function Sidebar:destroy()\nL38:   self.view = nil\nL39:   self.code = nil\nL40:   self.renderer = nil\nL41: end\nL42: \nL43: function Sidebar:reset()\nL44:   self.code = { buf = 0, win = 0 }\nL45: end\nL46: \nL47: function Sidebar:open()\nL48:   if not self.view:is_open() then\nL49:     self:intialize()\nL50:     self:render()\nL51:   else\nL52:     self:focus()\nL53:   end\nL54:   return self\nL55: end\nL56: \nL57: function Sidebar:toggle()\nL58:   if self.view:is_open() then\nL59:     self:close()\nL60:     return false\nL61:   else\nL62:     self:open()\nL63:     return true\nL64:   end\nL65: end\nL66: \nL67: function Sidebar:has_code_win()\nL68:   return self.code.win\nL69:       and self.code.buf\nL70:       and self.code.win ~= 0\nL71:       and self.code.buf ~= 0\nL72:       and api.nvim_win_is_valid(self.code.win)\nL73:       and api.nvim_buf_is_valid(self.code.buf)\nL74: end\nL75: \nL76: function Sidebar:focus_code()\nL77:   if self:has_code_win() then\nL78:     fn.win_gotoid(self.code.win)\nL79:     return true\nL80:   end\nL81:   return false\nL82: end\nL83: \nL84: function Sidebar:focus_toggle()\nL85:   if self.view:is_open() and self:has_code_win() then\nL86:     local winid = fn.win_getid()\nL87:     if winid == self.code.win then\nL88:       fn.win_gotoid(self.view.win)\nL89:     else\nL90:       fn.win_gotoid(self.code.win)\nL91:     end\nL92:     return true\nL93:   end\nL94:   return false\nL95: end\nL96: \nL97: local get_renderer_size_and_position = function()\nL98:   local renderer_width = math.ceil(vim.o.columns * 0.3)\nL99:   local renderer_height = vim.o.lines\nL100:   local renderer_position = vim.o.columns - renderer_width\nL101:   return renderer_width, renderer_height, renderer_position\nL102: end\nL103: \nL104: function Sidebar:intialize()\nL105:   self.code.win = api.nvim_get_current_win()\nL106:   self.code.buf = api.nvim_get_current_buf()\nL107: \nL108:   local split_command = \"botright vs\"\nL109:   local renderer_width, renderer_height, renderer_position = get_renderer_size_and_position()\nL110: \nL111:   self.view:setup(split_command, renderer_width)\nL112: \nL113:   local winid = fn.bufwinid(self.view.buf)\nL114:   --- setup coord\nL115:   self.renderer = Renderer.create({\nL116:     width = api.nvim_win_get_width(winid),\nL117:     height = renderer_height,\nL118:     position = renderer_position,\nL119:     relative = { type = \"win\", winid = winid },\nL120:   })\nL121: \nL122:   -- reset states when buffer is closed\nL123:   api.nvim_buf_attach(self.code.buf, false, {\nL124:     on_detach = function(_, _)\nL125:       self:reset()\nL126:     end,\nL127:   })\nL128: end\nL129: \nL130: function Sidebar:close()\nL131:   self.renderer:close()\nL132:   fn.win_gotoid(self.code.win)\nL133: end\nL134: \nL135: ---@return boolean\nL136: function Sidebar:focus()\nL137:   if self.view:is_open() then\nL138:     fn.win_gotoid(self.view.win)\nL139:     self.renderer:focus()\nL140:     return true\nL141:   end\nL142:   return false\nL143: end\nL144: \nL145: ---@param content string\nL146: ---@param jump? boolean\nL147: function Sidebar:update_content(content, jump)\nL148:   jump = jump or false\nL149: \nL150:   vim.defer_fn(function()\nL151:     api.nvim_set_option_value(\"modifiable\", true, { buf = self.view.buf })\nL152:     api.nvim_buf_set_lines(self.view.buf, 0, -1, false, vim.split(content, \"\\n\"))\nL153:     api.nvim_set_option_value(\"modifiable\", false, { buf = self.view.buf })\nL154:     api.nvim_set_option_value(\"filetype\", \"Avante\", { buf = self.view.buf })\nL155: \nL156:     -- Move to the bottom\nL157:     if jump then\nL158:       api.nvim_win_set_cursor(self.view.win, { api.nvim_buf_line_count(self.view.buf), 0 })\nL159:       api.nvim_set_current_win(self.code.win)\nL160:     else\nL161:       self.renderer:focus()\nL162:     end\nL163:   end, 0)\nL164: end\nL165: \nL166: local function parse_codeblocks(buf)\nL167:   local codeblocks = {}\nL168:   local in_codeblock = false\nL169:   local start_line = nil\nL170:   local lang = nil\nL171: \nL172:   local lines = api.nvim_buf_get_lines(buf, 0, -1, false)\nL173:   for i, line in ipairs(lines) do\nL174:     if line:match(\"^```\") then\nL175:       -- parse language\nL176:       local lang_ = line:match(\"^```(%w+)\")\nL177:       if in_codeblock and not lang_ then\nL178:         table.insert(codeblocks, { start_line = start_line, end_line = i - 1, lang = lang })\nL179:         in_codeblock = false\nL180:       elseif lang_ then\nL181:         lang = lang_\nL182:         start_line = i - 1\nL183:         in_codeblock = true\nL184:       end\nL185:     end\nL186:   end\nL187: \nL188:   return codeblocks\nL189: end\nL190: \nL191: ---@param codeblocks table<integer, any>\nL192: local function is_cursor_in_codeblock(codeblocks)\nL193:   local cursor_pos = api.nvim_win_get_cursor(0)\nL194:   local cursor_line = cursor_pos[1] - 1 -- 转换为 0-indexed 行号\nL195: \nL196:   for _, block in ipairs(codeblocks) do\nL197:     if cursor_line >= block.start_line and cursor_line <= block.end_line then\nL198:       return block\nL199:     end\nL200:   end\nL201: \nL202:   return nil\nL203: end\nL204: \nL205: local function prepend_line_number(content)\nL206:   local lines = vim.split(content, \"\\n\")\nL207:   local result = {}\nL208:   for i, line in ipairs(lines) do\nL209:     table.insert(result, \"L\" .. i .. \": \" .. line)\nL210:   end\nL211:   return table.concat(result, \"\\n\")\nL212: end\nL213: \nL214: local function extract_code_snippets(content)\nL215:   local snippets = {}\nL216:   local current_snippet = {}\nL217:   local in_code_block = false\nL218:   local lang, start_line, end_line\nL219:   local explanation = \"\"\nL220: \nL221:   for line in content:gmatch(\"[^\\r\\n]+\") do\nL222:     local start_line_str, end_line_str = line:match(\"^Replace lines: (%d+)-(%d+)\")\nL223:     if start_line_str ~= nil and end_line_str ~= nil then\nL224:       start_line = tonumber(start_line_str)\nL225:       end_line = tonumber(end_line_str)\nL226:     end\nL227:     if line:match(\"^```\") then\nL228:       if in_code_block then\nL229:         if start_line ~= nil and end_line ~= nil then\nL230:           table.insert(snippets, {\nL231:             range = { start_line, end_line },\nL232:             content = table.concat(current_snippet, \"\\n\"),\nL233:             lang = lang,\nL234:             explanation = explanation,\nL235:           })\nL236:         end\nL237:         current_snippet = {}\nL238:         start_line, end_line = nil, nil\nL239:         explanation = \"\"\nL240:         in_code_block = false\nL241:       else\nL242:         lang = line:match(\"^```(%w+)\")\nL243:         if not lang or lang == \"\" then\nL244:           lang = \"text\"\nL245:         end\nL246:         in_code_block = true\nL247:       end\nL248:     elseif in_code_block then\nL249:       table.insert(current_snippet, line)\nL250:     else\nL251:       explanation = explanation .. line .. \"\\n\"\nL252:     end\nL253:   end\nL254: \nL255:   return snippets\nL256: end\nL257: \nL258: -- Add a new function to display notifications\nL259: local function show_notification(message)\nL260:   vim.notify(message, vim.log.levels.INFO, {\nL261:     title = \"AI Assistant\",\nL262:     timeout = 3000,\nL263:   })\nL264: end\nL265: \nL266: -- Function to get the current project root directory\nL267: local function get_project_root()\nL268:   local current_file = fn.expand(\"%:p\")\nL269:   local current_dir = fn.fnamemodify(current_file, \":h\")\nL270:   local git_root = fn.systemlist(\"git -C \" .. fn.shellescape(current_dir) .. \" rev-parse --show-toplevel\")[1]\nL271:   return git_root or current_dir\nL272: end\nL273: \nL274: ---@param sidebar avante.Sidebar\nL275: local function get_chat_history_filename(sidebar)\nL276:   local code_buf_name = api.nvim_buf_get_name(sidebar.code.buf)\nL277:   local relative_path = fn.fnamemodify(code_buf_name, \":~:.\")\nL278:   -- Replace path separators with double underscores\nL279:   local path_with_separators = fn.substitute(relative_path, \"/\", \"__\", \"g\")\nL280:   -- Replace other non-alphanumeric characters with single underscores\nL281:   return fn.substitute(path_with_separators, \"[^A-Za-z0-9._]\", \"_\", \"g\")\nL282: end\nL283: \nL284: -- Function to get the chat history file path\nL285: local function get_chat_history_file(sidebar)\nL286:   local project_root = get_project_root()\nL287:   local filename = get_chat_history_filename(sidebar)\nL288:   local history_dir = Path:new(project_root, \".avante_chat_history\")\nL289:   return history_dir:joinpath(filename .. \".json\")\nL290: end\nL291: \nL292: -- Function to get current timestamp\nL293: local function get_timestamp()\nL294:   return os.date(\"%Y-%m-%d %H:%M:%S\")\nL295: end\nL296: \nL297: -- Function to load chat history\nL298: local function load_chat_history(sidebar)\nL299:   local history_file = get_chat_history_file(sidebar)\nL300:   if history_file:exists() then\nL301:     local content = history_file:read()\nL302:     return fn.json_decode(content)\nL", "requirement": "test"}, {"timestamp": "2024-08-17 14:24:32", "response": "```lua\nL1: local View = require(\"avante.view\")\nL2: \nL3: local Path = require(\"plenary.path\")\nL4: local N = require(\"nui-components\")\nL5: local Renderer = require(\"nui-components.renderer\")\nL6: local diff = require(\"avante.diff\")\nL7: local config = require(\"avante.config\")\nL8: local ai_bot = require(\"avante.ai_bot\")\nL9: local api = vim.api\nL10: local fn = vim.fn\nL11: \nL12: local CODEBLOCK_KEYBINDING_NAMESPACE = api.nvim_create_namespace(\"AVANTE_CODEBLOCK_KEYBINDING\")\nL13: local PRIORITY = vim.highlight.priorities.user\nL14: \nL15: ---@class avante.Sidebar\nL16: local Sidebar = {}\nL17: \nL18: ---@class avante.SidebarState\nL19: ---@field win integer\nL20: ---@field buf integer\nL21: \nL22: ---@class avante.Sidebar\nL23: ---@field id integer\nL24: ---@field view avante.View\nL25: ---@field code avante.SidebarState\nL26: ---@field renderer NuiRenderer\nL27: \nL28: function Sidebar:new(id)\nL29:   return setmetatable({\nL30:     id = id,\nL31:     code = { buf = 0, win = 0 },\nL32:     view = View:new(),\nL33:     renderer = nil,\nL34:   }, { __index = Sidebar })\nL35: end\nL36: \nL37: function Sidebar:destroy()\nL38:   self.view = nil\nL39:   self.code = nil\nL40:   self.renderer = nil\nL41: end\nL42: \nL43: function Sidebar:reset()\nL44:   self.code = { buf = 0, win = 0 }\nL45: end\nL46: \nL47: function Sidebar:open()\nL48:   if not self.view:is_open() then\nL49:     self:intialize()\nL50:     self:render()\nL51:   else\nL52:     self:focus()\nL53:   end\nL54:   return self\nL55: end\nL56: \nL57: function Sidebar:toggle()\nL58:   if self.view:is_open() then\nL59:     self:close()\nL60:     return false\nL61:   else\nL62:     self:open()\nL63:     return true\nL64:   end\nL65: end\nL66: \nL67: function Sidebar:has_code_win()\nL68:   return self.code.win\nL69:       and self.code.buf\nL70:       and self.code.win ~= 0\nL71:       and self.code.buf ~= 0\nL72:       and api.nvim_win_is_valid(self.code.win)\nL73:       and api.nvim_buf_is_valid(self.code.buf)\nL74: end\nL75: \nL76: function Sidebar:focus_code()\nL77:   if self:has_code_win() then\nL78:     fn.win_gotoid(self.code.win)\nL79:     return true\nL80:   end\nL81:   return false\nL82: end\nL83: \nL84: function Sidebar:focus_toggle()\nL85:   if self.view:is_open() and self:has_code_win() then\nL86:     local winid = fn.win_getid()\nL87:     if winid == self.code.win then\nL88:       fn.win_gotoid(self.view.win)\nL89:     else\nL90:       fn.win_gotoid(self.code.win)\nL91:     end\nL92:     return true\nL93:   end\nL94:   return false\nL95: end\nL96: \nL97: local get_renderer_size_and_position = function()\nL98:   local renderer_width = math.ceil(vim.o.columns * 0.3)\nL99:   local renderer_height = vim.o.lines\nL100:   local renderer_position = vim.o.columns - renderer_width\nL101:   return renderer_width, renderer_height, renderer_position\nL102: end\nL103: \nL104: function Sidebar:intialize()\nL105:   self.code.win = api.nvim_get_current_win()\nL106:   self.code.buf = api.nvim_get_current_buf()\nL107: \nL108:   local split_command = \"botright vs\"\nL109:   local renderer_width, renderer_height, renderer_position = get_renderer_size_and_position()\nL110: \nL111:   self.view:setup(split_command, renderer_width)\nL112: \nL113:   local winid = fn.bufwinid(self.view.buf)\nL114:   --- setup coord\nL115:   self.renderer = Renderer.create({\nL116:     width = api.nvim_win_get_width(winid),\nL117:     height = renderer_height,\nL118:     position = renderer_position,\nL119:     relative = { type = \"win\", winid = winid },\nL120:   })\nL121: \nL122:   -- reset states when buffer is closed\nL123:   api.nvim_buf_attach(self.code.buf, false, {\nL124:     on_detach = function(_, _)\nL125:       self:reset()\nL126:     end,\nL127:   })\nL128: end\nL129: \nL130: function Sidebar:close()\nL131:   self.renderer:close()\nL132:   fn.win_gotoid(self.code.win)\nL133: end\nL134: \nL135: ---@return boolean\nL136: function Sidebar:focus()\nL137:   if self.view:is_open() then\nL138:     fn.win_gotoid(self.view.win)\nL139:     self.renderer:focus()\nL140:     return true\nL141:   end\nL142:   return false\nL143: end\nL144: \nL145: ---@param content string\nL146: ---@param jump? boolean\nL147: function Sidebar:update_content(content, jump)\nL148:   jump = jump or false\nL149: \nL150:   vim.defer_fn(function()\nL151:     api.nvim_set_option_value(\"modifiable\", true, { buf = self.view.buf })\nL152:     api.nvim_buf_set_lines(self.view.buf, 0, -1, false, vim.split(content, \"\\n\"))\nL153:     api.nvim_set_option_value(\"modifiable\", false, { buf = self.view.buf })\nL154:     api.nvim_set_option_value(\"filetype\", \"Avante\", { buf = self.view.buf })\nL155: \nL156:     -- Move to the bottom\nL157:     if jump then\nL158:       api.nvim_win_set_cursor(self.view.win, { api.nvim_buf_line_count(self.view.buf), 0 })\nL159:       api.nvim_set_current_win(self.code.win)\nL160:     else\nL161:       self.renderer:focus()\nL162:     end\nL163:   end, 0)\nL164: end\nL165: \nL166: local function parse_codeblocks(buf)\nL167:   local codeblocks = {}\nL168:   local in_codeblock = false\nL169:   local start_line = nil\nL170:   local lang = nil\nL171: \nL172:   local lines = api.nvim_buf_get_lines(buf, 0, -1, false)\nL173:   for i, line in ipairs(lines) do\nL174:     if line:match(\"^```\") then\nL175:       -- parse language\nL176:       local lang_ = line:match(\"^```(%w+)\")\nL177:       if in_codeblock and not lang_ then\nL178:         table.insert(codeblocks, { start_line = start_line, end_line = i - 1, lang = lang })\nL179:         in_codeblock = false\nL180:       elseif lang_ then\nL181:         lang = lang_\nL182:         start_line = i - 1\nL183:         in_codeblock = true\nL184:       end\nL185:     end\nL186:   end\nL187: \nL188:   return codeblocks\nL189: end\nL190: \nL191: ---@param codeblocks table<integer, any>\nL192: local function is_cursor_in_codeblock(codeblocks)\nL193:   local cursor_pos = api.nvim_win_get_cursor(0)\nL194:   local cursor_line = cursor_pos[1] - 1 -- 转换为 0-indexed 行号\nL195: \nL196:   for _, block in ipairs(codeblocks) do\nL197:     if cursor_line >= block.start_line and cursor_line <= block.end_line then\nL198:       return block\nL199:     end\nL200:   end\nL201: \nL202:   return nil\nL203: end\nL204: \nL205: local function prepend_line_number(content)\nL206:   local lines = vim.split(content, \"\\n\")\nL207:   local result = {}\nL208:   for i, line in ipairs(lines) do\nL209:     table.insert(result, \"L\" .. i .. \": \" .. line)\nL210:   end\nL211:   return table.concat(result, \"\\n\")\nL212: end\nL213: \nL214: local function extract_code_snippets(content)\nL215:   local snippets = {}\nL216:   local current_snippet = {}\nL217:   local in_code_block = false\nL218:   local lang, start_line, end_line\nL219:   local explanation = \"\"\nL220: \nL221:   for line in content:gmatch(\"[^\\r\\n]+\") do\nL222:     local start_line_str, end_line_str = line:match(\"^Replace lines: (%d+)-(%d+)\")\nL223:     if start_line_str ~= nil and end_line_str ~= nil then\nL224:       start_line = tonumber(start_line_str)\nL225:       end_line = tonumber(end_line_str)\nL226:     end\nL227:     if line:match(\"^```\") then\nL228:       if in_code_block then\nL229:         if start_line ~= nil and end_line ~= nil then\nL230:           table.insert(snippets, {\nL231:             range = { start_line, end_line },\nL232:             content = table.concat(current_snippet, \"\\n\"),\nL233:             lang = lang,\nL234:             explanation = explanation,\nL235:           })\nL236:         end\nL237:         current_snippet = {}\nL238:         start_line, end_line = nil, nil\nL239:         explanation = \"\"\nL240:         in_code_block = false\nL241:       else\nL242:         lang = line:match(\"^```(%w+)\")\nL243:         if not lang or lang == \"\" then\nL244:           lang = \"text\"\nL245:         end\nL246:         in_code_block = true\nL247:       end\nL248:     elseif in_code_block then\nL249:       table.insert(current_snippet, line)\nL250:     else\nL251:       explanation = explanation .. line .. \"\\n\"\nL252:     end\nL253:   end\nL254: \nL255:   return snippets\nL256: end\nL257: \nL258: -- Add a new function to display notifications\nL259: local function show_notification(message)\nL260:   vim.notify(message, vim.log.levels.INFO, {\nL261:     title = \"AI Assistant\",\nL262:     timeout = 3000,\nL263:   })\nL264: end\nL265: \nL266: -- Function to get the current project root directory\nL267: local function get_project_root()\nL268:   local current_file = fn.expand(\"%:p\")\nL269:   local current_dir = fn.fnamemodify(current_file, \":h\")\nL270:   local git_root = fn.systemlist(\"git -C \" .. fn.shellescape(current_dir) .. \" rev-parse --show-toplevel\")[1]\nL271:   return git_root or current_dir\nL272: end\nL273: \nL274: ---@param sidebar avante.Sidebar\nL275: local function get_chat_history_filename(sidebar)\nL276:   local code_buf_name = api.nvim_buf_get_name(sidebar.code.buf)\nL277:   local relative_path = fn.fnamemodify(code_buf_name, \":~:.\")\nL278:   -- Replace path separators with double underscores\nL279:   local path_with_separators = fn.substitute(relative_path, \"/\", \"__\", \"g\")\nL280:   -- Replace other non-alphanumeric characters with single underscores\nL281:   return fn.substitute(path_with_separators, \"[^A-Za-z0-9._]\", \"_\", \"g\")\nL282: end\nL283: \nL284: -- Function to get the chat history file path\nL285: local function get_chat_history_file(sidebar)\nL286:   local project_root = get_project_root()\nL287:   local filename = get_chat_history_filename(sidebar)\nL288:   local history_dir = Path:new(project_root, \".avante_chat_history\")\nL289:   return history_dir:joinpath(filename .. \".json\")\nL290: end\nL291: \nL292: -- Function to get current timestamp\nL293: local function get_timestamp()\nL294:   return os.date(\"%Y-%m-%d %H:%M:%S\")\nL295: end\nL296: \nL297: -- Function to load chat history\nL298: local function load_chat_history(sidebar)\nL299:   local history_file = get_chat_history_file(sidebar)\nL300:   if history_file:exists() then\nL301:     local content = history_file:read()\nL302:     return fn.json_decode(content)\nL", "requirement": "\n\n\n\n\n\n\n\n"}, {"timestamp": "2024-08-17 14:24:31", "response": "```lua\nL1: local View = require(\"avante.view\")\nL2: \nL3: local Path = require(\"plenary.path\")\nL4: local N = require(\"nui-components\")\nL5: local Renderer = require(\"nui-components.renderer\")\nL6: local diff = require(\"avante.diff\")\nL7: local config = require(\"avante.config\")\nL8: local ai_bot = require(\"avante.ai_bot\")\nL9: local api = vim.api\nL10: local fn = vim.fn\nL11: \nL12: local CODEBLOCK_KEYBINDING_NAMESPACE = api.nvim_create_namespace(\"AVANTE_CODEBLOCK_KEYBINDING\")\nL13: local PRIORITY = vim.highlight.priorities.user\nL14: \nL15: ---@class avante.Sidebar\nL16: local Sidebar = {}\nL17: \nL18: ---@class avante.SidebarState\nL19: ---@field win integer\nL20: ---@field buf integer\nL21: \nL22: ---@class avante.Sidebar\nL23: ---@field id integer\nL24: ---@field view avante.View\nL25: ---@field code avante.SidebarState\nL26: ---@field renderer NuiRenderer\nL27: \nL28: function Sidebar:new(id)\nL29:   return setmetatable({\nL30:     id = id,\nL31:     code = { buf = 0, win = 0 },\nL32:     view = View:new(),\nL33:     renderer = nil,\nL34:   }, { __index = Sidebar })\nL35: end\nL36: \nL37: function Sidebar:destroy()\nL38:   self.view = nil\nL39:   self.code = nil\nL40:   self.renderer = nil\nL41: end\nL42: \nL43: function Sidebar:reset()\nL44:   self.code = { buf = 0, win = 0 }\nL45: end\nL46: \nL47: function Sidebar:open()\nL48:   if not self.view:is_open() then\nL49:     self:intialize()\nL50:     self:render()\nL51:   else\nL52:     self:focus()\nL53:   end\nL54:   return self\nL55: end\nL56: \nL57: function Sidebar:toggle()\nL58:   if self.view:is_open() then\nL59:     self:close()\nL60:     return false\nL61:   else\nL62:     self:open()\nL63:     return true\nL64:   end\nL65: end\nL66: \nL67: function Sidebar:has_code_win()\nL68:   return self.code.win\nL69:       and self.code.buf\nL70:       and self.code.win ~= 0\nL71:       and self.code.buf ~= 0\nL72:       and api.nvim_win_is_valid(self.code.win)\nL73:       and api.nvim_buf_is_valid(self.code.buf)\nL74: end\nL75: \nL76: function Sidebar:focus_code()\nL77:   if self:has_code_win() then\nL78:     fn.win_gotoid(self.code.win)\nL79:     return true\nL80:   end\nL81:   return false\nL82: end\nL83: \nL84: function Sidebar:focus_toggle()\nL85:   if self.view:is_open() and self:has_code_win() then\nL86:     local winid = fn.win_getid()\nL87:     if winid == self.code.win then\nL88:       fn.win_gotoid(self.view.win)\nL89:     else\nL90:       fn.win_gotoid(self.code.win)\nL91:     end\nL92:     return true\nL93:   end\nL94:   return false\nL95: end\nL96: \nL97: local get_renderer_size_and_position = function()\nL98:   local renderer_width = math.ceil(vim.o.columns * 0.3)\nL99:   local renderer_height = vim.o.lines\nL100:   local renderer_position = vim.o.columns - renderer_width\nL101:   return renderer_width, renderer_height, renderer_position\nL102: end\nL103: \nL104: function Sidebar:intialize()\nL105:   self.code.win = api.nvim_get_current_win()\nL106:   self.code.buf = api.nvim_get_current_buf()\nL107: \nL108:   local split_command = \"botright vs\"\nL109:   local renderer_width, renderer_height, renderer_position = get_renderer_size_and_position()\nL110: \nL111:   self.view:setup(split_command, renderer_width)\nL112: \nL113:   local winid = fn.bufwinid(self.view.buf)\nL114:   --- setup coord\nL115:   self.renderer = Renderer.create({\nL116:     width = api.nvim_win_get_width(winid),\nL117:     height = renderer_height,\nL118:     position = renderer_position,\nL119:     relative = { type = \"win\", winid = winid },\nL120:   })\nL121: \nL122:   -- reset states when buffer is closed\nL123:   api.nvim_buf_attach(self.code.buf, false, {\nL124:     on_detach = function(_, _)\nL125:       self:reset()\nL126:     end,\nL127:   })\nL128: end\nL129: \nL130: function Sidebar:close()\nL131:   self.renderer:close()\nL132:   fn.win_gotoid(self.code.win)\nL133: end\nL134: \nL135: ---@return boolean\nL136: function Sidebar:focus()\nL137:   if self.view:is_open() then\nL138:     fn.win_gotoid(self.view.win)\nL139:     self.renderer:focus()\nL140:     return true\nL141:   end\nL142:   return false\nL143: end\nL144: \nL145: ---@param content string\nL146: ---@param jump? boolean\nL147: function Sidebar:update_content(content, jump)\nL148:   jump = jump or false\nL149: \nL150:   vim.defer_fn(function()\nL151:     api.nvim_set_option_value(\"modifiable\", true, { buf = self.view.buf })\nL152:     api.nvim_buf_set_lines(self.view.buf, 0, -1, false, vim.split(content, \"\\n\"))\nL153:     api.nvim_set_option_value(\"modifiable\", false, { buf = self.view.buf })\nL154:     api.nvim_set_option_value(\"filetype\", \"Avante\", { buf = self.view.buf })\nL155: \nL156:     -- Move to the bottom\nL157:     if jump then\nL158:       api.nvim_win_set_cursor(self.view.win, { api.nvim_buf_line_count(self.view.buf), 0 })\nL159:       api.nvim_set_current_win(self.code.win)\nL160:     else\nL161:       self.renderer:focus()\nL162:     end\nL163:   end, 0)\nL164: end\nL165: \nL166: local function parse_codeblocks(buf)\nL167:   local codeblocks = {}\nL168:   local in_codeblock = false\nL169:   local start_line = nil\nL170:   local lang = nil\nL171: \nL172:   local lines = api.nvim_buf_get_lines(buf, 0, -1, false)\nL173:   for i, line in ipairs(lines) do\nL174:     if line:match(\"^```\") then\nL175:       -- parse language\nL176:       local lang_ = line:match(\"^```(%w+)\")\nL177:       if in_codeblock and not lang_ then\nL178:         table.insert(codeblocks, { start_line = start_line, end_line = i - 1, lang = lang })\nL179:         in_codeblock = false\nL180:       elseif lang_ then\nL181:         lang = lang_\nL182:         start_line = i - 1\nL183:         in_codeblock = true\nL184:       end\nL185:     end\nL186:   end\nL187: \nL188:   return codeblocks\nL189: end\nL190: \nL191: ---@param codeblocks table<integer, any>\nL192: local function is_cursor_in_codeblock(codeblocks)\nL193:   local cursor_pos = api.nvim_win_get_cursor(0)\nL194:   local cursor_line = cursor_pos[1] - 1 -- 转换为 0-indexed 行号\nL195: \nL196:   for _, block in ipairs(codeblocks) do\nL197:     if cursor_line >= block.start_line and cursor_line <= block.end_line then\nL198:       return block\nL199:     end\nL200:   end\nL201: \nL202:   return nil\nL203: end\nL204: \nL205: local function prepend_line_number(content)\nL206:   local lines = vim.split(content, \"\\n\")\nL207:   local result = {}\nL208:   for i, line in ipairs(lines) do\nL209:     table.insert(result, \"L\" .. i .. \": \" .. line)\nL210:   end\nL211:   return table.concat(result, \"\\n\")\nL212: end\nL213: \nL214: local function extract_code_snippets(content)\nL215:   local snippets = {}\nL216:   local current_snippet = {}\nL217:   local in_code_block = false\nL218:   local lang, start_line, end_line\nL219:   local explanation = \"\"\nL220: \nL221:   for line in content:gmatch(\"[^\\r\\n]+\") do\nL222:     local start_line_str, end_line_str = line:match(\"^Replace lines: (%d+)-(%d+)\")\nL223:     if start_line_str ~= nil and end_line_str ~= nil then\nL224:       start_line = tonumber(start_line_str)\nL225:       end_line = tonumber(end_line_str)\nL226:     end\nL227:     if line:match(\"^```\") then\nL228:       if in_code_block then\nL229:         if start_line ~= nil and end_line ~= nil then\nL230:           table.insert(snippets, {\nL231:             range = { start_line, end_line },\nL232:             content = table.concat(current_snippet, \"\\n\"),\nL233:             lang = lang,\nL234:             explanation = explanation,\nL235:           })\nL236:         end\nL237:         current_snippet = {}\nL238:         start_line, end_line = nil, nil\nL239:         explanation = \"\"\nL240:         in_code_block = false\nL241:       else\nL242:         lang = line:match(\"^```(%w+)\")\nL243:         if not lang or lang == \"\" then\nL244:           lang = \"text\"\nL245:         end\nL246:         in_code_block = true\nL247:       end\nL248:     elseif in_code_block then\nL249:       table.insert(current_snippet, line)\nL250:     else\nL251:       explanation = explanation .. line .. \"\\n\"\nL252:     end\nL253:   end\nL254: \nL255:   return snippets\nL256: end\nL257: \nL258: -- Add a new function to display notifications\nL259: local function show_notification(message)\nL260:   vim.notify(message, vim.log.levels.INFO, {\nL261:     title = \"AI Assistant\",\nL262:     timeout = 3000,\nL263:   })\nL264: end\nL265: \nL266: -- Function to get the current project root directory\nL267: local function get_project_root()\nL268:   local current_file = fn.expand(\"%:p\")\nL269:   local current_dir = fn.fnamemodify(current_file, \":h\")\nL270:   local git_root = fn.systemlist(\"git -C \" .. fn.shellescape(current_dir) .. \" rev-parse --show-toplevel\")[1]\nL271:   return git_root or current_dir\nL272: end\nL273: \nL274: ---@param sidebar avante.Sidebar\nL275: local function get_chat_history_filename(sidebar)\nL276:   local code_buf_name = api.nvim_buf_get_name(sidebar.code.buf)\nL277:   local relative_path = fn.fnamemodify(code_buf_name, \":~:.\")\nL278:   -- Replace path separators with double underscores\nL279:   local path_with_separators = fn.substitute(relative_path, \"/\", \"__\", \"g\")\nL280:   -- Replace other non-alphanumeric characters with single underscores\nL281:   return fn.substitute(path_with_separators, \"[^A-Za-z0-9._]\", \"_\", \"g\")\nL282: end\nL283: \nL284: -- Function to get the chat history file path\nL285: local function get_chat_history_file(sidebar)\nL286:   local project_root = get_project_root()\nL287:   local filename = get_chat_history_filename(sidebar)\nL288:   local history_dir = Path:new(project_root, \".avante_chat_history\")\nL289:   return history_dir:joinpath(filename .. \".json\")\nL290: end\nL291: \nL292: -- Function to get current timestamp\nL293: local function get_timestamp()\nL294:   return os.date(\"%Y-%m-%d %H:%M:%S\")\nL295: end\nL296: \nL297: -- Function to load chat history\nL298: local function load_chat_history(sidebar)\nL299:   local history_file = get_chat_history_file(sidebar)\nL300:   if history_file:exists() then\nL301:     local content = history_file:read()\nL302:     return fn.json_decode(content)\nL", "requirement": "\n\n\n\n"}, {"timestamp": "2024-08-17 14:24:30", "response": "```lua\nL1: local View = require(\"avante.view\")\nL2: \nL3: local Path = require(\"plenary.path\")\nL4: local N = require(\"nui-components\")\nL5: local Renderer = require(\"nui-components.renderer\")\nL6: local diff = require(\"avante.diff\")\nL7: local config = require(\"avante.config\")\nL8: local ai_bot = require(\"avante.ai_bot\")\nL9: local api = vim.api\nL10: local fn = vim.fn\nL11: \nL12: local CODEBLOCK_KEYBINDING_NAMESPACE = api.nvim_create_namespace(\"AVANTE_CODEBLOCK_KEYBINDING\")\nL13: local PRIORITY = vim.highlight.priorities.user\nL14: \nL15: ---@class avante.Sidebar\nL16: local Sidebar = {}\nL17: \nL18: ---@class avante.SidebarState\nL19: ---@field win integer\nL20: ---@field buf integer\nL21: \nL22: ---@class avante.Sidebar\nL23: ---@field id integer\nL24: ---@field view avante.View\nL25: ---@field code avante.SidebarState\nL26: ---@field renderer NuiRenderer\nL27: \nL28: function Sidebar:new(id)\nL29:   return setmetatable({\nL30:     id = id,\nL31:     code = { buf = 0, win = 0 },\nL32:     view = View:new(),\nL33:     renderer = nil,\nL34:   }, { __index = Sidebar })\nL35: end\nL36: \nL37: function Sidebar:destroy()\nL38:   self.view = nil\nL39:   self.code = nil\nL40:   self.renderer = nil\nL41: end\nL42: \nL43: function Sidebar:reset()\nL44:   self.code = { buf = 0, win = 0 }\nL45: end\nL46: \nL47: function Sidebar:open()\nL48:   if not self.view:is_open() then\nL49:     self:intialize()\nL50:     self:render()\nL51:   else\nL52:     self:focus()\nL53:   end\nL54:   return self\nL55: end\nL56: \nL57: function Sidebar:toggle()\nL58:   if self.view:is_open() then\nL59:     self:close()\nL60:     return false\nL61:   else\nL62:     self:open()\nL63:     return true\nL64:   end\nL65: end\nL66: \nL67: function Sidebar:has_code_win()\nL68:   return self.code.win\nL69:       and self.code.buf\nL70:       and self.code.win ~= 0\nL71:       and self.code.buf ~= 0\nL72:       and api.nvim_win_is_valid(self.code.win)\nL73:       and api.nvim_buf_is_valid(self.code.buf)\nL74: end\nL75: \nL76: function Sidebar:focus_code()\nL77:   if self:has_code_win() then\nL78:     fn.win_gotoid(self.code.win)\nL79:     return true\nL80:   end\nL81:   return false\nL82: end\nL83: \nL84: function Sidebar:focus_toggle()\nL85:   if self.view:is_open() and self:has_code_win() then\nL86:     local winid = fn.win_getid()\nL87:     if winid == self.code.win then\nL88:       fn.win_gotoid(self.view.win)\nL89:     else\nL90:       fn.win_gotoid(self.code.win)\nL91:     end\nL92:     return true\nL93:   end\nL94:   return false\nL95: end\nL96: \nL97: local get_renderer_size_and_position = function()\nL98:   local renderer_width = math.ceil(vim.o.columns * 0.3)\nL99:   local renderer_height = vim.o.lines\nL100:   local renderer_position = vim.o.columns - renderer_width\nL101:   return renderer_width, renderer_height, renderer_position\nL102: end\nL103: \nL104: function Sidebar:intialize()\nL105:   self.code.win = api.nvim_get_current_win()\nL106:   self.code.buf = api.nvim_get_current_buf()\nL107: \nL108:   local split_command = \"botright vs\"\nL109:   local renderer_width, renderer_height, renderer_position = get_renderer_size_and_position()\nL110: \nL111:   self.view:setup(split_command, renderer_width)\nL112: \nL113:   local winid = fn.bufwinid(self.view.buf)\nL114:   --- setup coord\nL115:   self.renderer = Renderer.create({\nL116:     width = api.nvim_win_get_width(winid),\nL117:     height = renderer_height,\nL118:     position = renderer_position,\nL119:     relative = { type = \"win\", winid = winid },\nL120:   })\nL121: \nL122:   -- reset states when buffer is closed\nL123:   api.nvim_buf_attach(self.code.buf, false, {\nL124:     on_detach = function(_, _)\nL125:       self:reset()\nL126:     end,\nL127:   })\nL128: end\nL129: \nL130: function Sidebar:close()\nL131:   self.renderer:close()\nL132:   fn.win_gotoid(self.code.win)\nL133: end\nL134: \nL135: ---@return boolean\nL136: function Sidebar:focus()\nL137:   if self.view:is_open() then\nL138:     fn.win_gotoid(self.view.win)\nL139:     self.renderer:focus()\nL140:     return true\nL141:   end\nL142:   return false\nL143: end\nL144: \nL145: ---@param content string\nL146: ---@param jump? boolean\nL147: function Sidebar:update_content(content, jump)\nL148:   jump = jump or false\nL149: \nL150:   vim.defer_fn(function()\nL151:     api.nvim_set_option_value(\"modifiable\", true, { buf = self.view.buf })\nL152:     api.nvim_buf_set_lines(self.view.buf, 0, -1, false, vim.split(content, \"\\n\"))\nL153:     api.nvim_set_option_value(\"modifiable\", false, { buf = self.view.buf })\nL154:     api.nvim_set_option_value(\"filetype\", \"Avante\", { buf = self.view.buf })\nL155: \nL156:     -- Move to the bottom\nL157:     if jump then\nL158:       api.nvim_win_set_cursor(self.view.win, { api.nvim_buf_line_count(self.view.buf), 0 })\nL159:       api.nvim_set_current_win(self.code.win)\nL160:     else\nL161:       self.renderer:focus()\nL162:     end\nL163:   end, 0)\nL164: end\nL165: \nL166: local function parse_codeblocks(buf)\nL167:   local codeblocks = {}\nL168:   local in_codeblock = false\nL169:   local start_line = nil\nL170:   local lang = nil\nL171: \nL172:   local lines = api.nvim_buf_get_lines(buf, 0, -1, false)\nL173:   for i, line in ipairs(lines) do\nL174:     if line:match(\"^```\") then\nL175:       -- parse language\nL176:       local lang_ = line:match(\"^```(%w+)\")\nL177:       if in_codeblock and not lang_ then\nL178:         table.insert(codeblocks, { start_line = start_line, end_line = i - 1, lang = lang })\nL179:         in_codeblock = false\nL180:       elseif lang_ then\nL181:         lang = lang_\nL182:         start_line = i - 1\nL183:         in_codeblock = true\nL184:       end\nL185:     end\nL186:   end\nL187: \nL188:   return codeblocks\nL189: end\nL190: \nL191: ---@param codeblocks table<integer, any>\nL192: local function is_cursor_in_codeblock(codeblocks)\nL193:   local cursor_pos = api.nvim_win_get_cursor(0)\nL194:   local cursor_line = cursor_pos[1] - 1 -- 转换为 0-indexed 行号\nL195: \nL196:   for _, block in ipairs(codeblocks) do\nL197:     if cursor_line >= block.start_line and cursor_line <= block.end_line then\nL198:       return block\nL199:     end\nL200:   end\nL201: \nL202:   return nil\nL203: end\nL204: \nL205: local function prepend_line_number(content)\nL206:   local lines = vim.split(content, \"\\n\")\nL207:   local result = {}\nL208:   for i, line in ipairs(lines) do\nL209:     table.insert(result, \"L\" .. i .. \": \" .. line)\nL210:   end\nL211:   return table.concat(result, \"\\n\")\nL212: end\nL213: \nL214: local function extract_code_snippets(content)\nL215:   local snippets = {}\nL216:   local current_snippet = {}\nL217:   local in_code_block = false\nL218:   local lang, start_line, end_line\nL219:   local explanation = \"\"\nL220: \nL221:   for line in content:gmatch(\"[^\\r\\n]+\") do\nL222:     local start_line_str, end_line_str = line:match(\"^Replace lines: (%d+)-(%d+)\")\nL223:     if start_line_str ~= nil and end_line_str ~= nil then\nL224:       start_line = tonumber(start_line_str)\nL225:       end_line = tonumber(end_line_str)\nL226:     end\nL227:     if line:match(\"^```\") then\nL228:       if in_code_block then\nL229:         if start_line ~= nil and end_line ~= nil then\nL230:           table.insert(snippets, {\nL231:             range = { start_line, end_line },\nL232:             content = table.concat(current_snippet, \"\\n\"),\nL233:             lang = lang,\nL234:             explanation = explanation,\nL235:           })\nL236:         end\nL237:         current_snippet = {}\nL238:         start_line, end_line = nil, nil\nL239:         explanation = \"\"\nL240:         in_code_block = false\nL241:       else\nL242:         lang = line:match(\"^```(%w+)\")\nL243:         if not lang or lang == \"\" then\nL244:           lang = \"text\"\nL245:         end\nL246:         in_code_block = true\nL247:       end\nL248:     elseif in_code_block then\nL249:       table.insert(current_snippet, line)\nL250:     else\nL251:       explanation = explanation .. line .. \"\\n\"\nL252:     end\nL253:   end\nL254: \nL255:   return snippets\nL256: end\nL257: \nL258: -- Add a new function to display notifications\nL259: local function show_notification(message)\nL260:   vim.notify(message, vim.log.levels.INFO, {\nL261:     title = \"AI Assistant\",\nL262:     timeout = 3000,\nL263:   })\nL264: end\nL265: \nL266: -- Function to get the current project root directory\nL267: local function get_project_root()\nL268:   local current_file = fn.expand(\"%:p\")\nL269:   local current_dir = fn.fnamemodify(current_file, \":h\")\nL270:   local git_root = fn.systemlist(\"git -C \" .. fn.shellescape(current_dir) .. \" rev-parse --show-toplevel\")[1]\nL271:   return git_root or current_dir\nL272: end\nL273: \nL274: ---@param sidebar avante.Sidebar\nL275: local function get_chat_history_filename(sidebar)\nL276:   local code_buf_name = api.nvim_buf_get_name(sidebar.code.buf)\nL277:   local relative_path = fn.fnamemodify(code_buf_name, \":~:.\")\nL278:   -- Replace path separators with double underscores\nL279:   local path_with_separators = fn.substitute(relative_path, \"/\", \"__\", \"g\")\nL280:   -- Replace other non-alphanumeric characters with single underscores\nL281:   return fn.substitute(path_with_separators, \"[^A-Za-z0-9._]\", \"_\", \"g\")\nL282: end\nL283: \nL284: -- Function to get the chat history file path\nL285: local function get_chat_history_file(sidebar)\nL286:   local project_root = get_project_root()\nL287:   local filename = get_chat_history_filename(sidebar)\nL288:   local history_dir = Path:new(project_root, \".avante_chat_history\")\nL289:   return history_dir:joinpath(filename .. \".json\")\nL290: end\nL291: \nL292: -- Function to get current timestamp\nL293: local function get_timestamp()\nL294:   return os.date(\"%Y-%m-%d %H:%M:%S\")\nL295: end\nL296: \nL297: -- Function to load chat history\nL298: local function load_chat_history(sidebar)\nL299:   local history_file = get_chat_history_file(sidebar)\nL300:   if history_file:exists() then\nL301:     local content = history_file:read()\nL302:     return fn.json_decode(content)\nL", "requirement": "\n\n"}, {"timestamp": "2024-08-17 14:24:31", "response": "```lua\nL1: local View = require(\"avante.view\")\nL2: \nL3: local Path = require(\"plenary.path\")\nL4: local N = require(\"nui-components\")\nL5: local Renderer = require(\"nui-components.renderer\")\nL6: local diff = require(\"avante.diff\")\nL7: local config = require(\"avante.config\")\nL8: local ai_bot = require(\"avante.ai_bot\")\nL9: local api = vim.api\nL10: local fn = vim.fn\nL11: \nL12: local CODEBLOCK_KEYBINDING_NAMESPACE = api.nvim_create_namespace(\"AVANTE_CODEBLOCK_KEYBINDING\")\nL13: local PRIORITY = vim.highlight.priorities.user\nL14: \nL15: ---@class avante.Sidebar\nL16: local Sidebar = {}\nL17: \nL18: ---@class avante.SidebarState\nL19: ---@field win integer\nL20: ---@field buf integer\nL21: \nL22: ---@class avante.Sidebar\nL23: ---@field id integer\nL24: ---@field view avante.View\nL25: ---@field code avante.SidebarState\nL26: ---@field renderer NuiRenderer\nL27: \nL28: function Sidebar:new(id)\nL29:   return setmetatable({\nL30:     id = id,\nL31:     code = { buf = 0, win = 0 },\nL32:     view = View:new(),\nL33:     renderer = nil,\nL34:   }, { __index = Sidebar })\nL35: end\nL36: \nL37: function Sidebar:destroy()\nL38:   self.view = nil\nL39:   self.code = nil\nL40:   self.renderer = nil\nL41: end\nL42: \nL43: function Sidebar:reset()\nL44:   self.code = { buf = 0, win = 0 }\nL45: end\nL46: \nL47: function Sidebar:open()\nL48:   if not self.view:is_open() then\nL49:     self:intialize()\nL50:     self:render()\nL51:   else\nL52:     self:focus()\nL53:   end\nL54:   return self\nL55: end\nL56: \nL57: function Sidebar:toggle()\nL58:   if self.view:is_open() then\nL59:     self:close()\nL60:     return false\nL61:   else\nL62:     self:open()\nL63:     return true\nL64:   end\nL65: end\nL66: \nL67: function Sidebar:has_code_win()\nL68:   return self.code.win\nL69:       and self.code.buf\nL70:       and self.code.win ~= 0\nL71:       and self.code.buf ~= 0\nL72:       and api.nvim_win_is_valid(self.code.win)\nL73:       and api.nvim_buf_is_valid(self.code.buf)\nL74: end\nL75: \nL76: function Sidebar:focus_code()\nL77:   if self:has_code_win() then\nL78:     fn.win_gotoid(self.code.win)\nL79:     return true\nL80:   end\nL81:   return false\nL82: end\nL83: \nL84: function Sidebar:focus_toggle()\nL85:   if self.view:is_open() and self:has_code_win() then\nL86:     local winid = fn.win_getid()\nL87:     if winid == self.code.win then\nL88:       fn.win_gotoid(self.view.win)\nL89:     else\nL90:       fn.win_gotoid(self.code.win)\nL91:     end\nL92:     return true\nL93:   end\nL94:   return false\nL95: end\nL96: \nL97: local get_renderer_size_and_position = function()\nL98:   local renderer_width = math.ceil(vim.o.columns * 0.3)\nL99:   local renderer_height = vim.o.lines\nL100:   local renderer_position = vim.o.columns - renderer_width\nL101:   return renderer_width, renderer_height, renderer_position\nL102: end\nL103: \nL104: function Sidebar:intialize()\nL105:   self.code.win = api.nvim_get_current_win()\nL106:   self.code.buf = api.nvim_get_current_buf()\nL107: \nL108:   local split_command = \"botright vs\"\nL109:   local renderer_width, renderer_height, renderer_position = get_renderer_size_and_position()\nL110: \nL111:   self.view:setup(split_command, renderer_width)\nL112: \nL113:   local winid = fn.bufwinid(self.view.buf)\nL114:   --- setup coord\nL115:   self.renderer = Renderer.create({\nL116:     width = api.nvim_win_get_width(winid),\nL117:     height = renderer_height,\nL118:     position = renderer_position,\nL119:     relative = { type = \"win\", winid = winid },\nL120:   })\nL121: \nL122:   -- reset states when buffer is closed\nL123:   api.nvim_buf_attach(self.code.buf, false, {\nL124:     on_detach = function(_, _)\nL125:       self:reset()\nL126:     end,\nL127:   })\nL128: end\nL129: \nL130: function Sidebar:close()\nL131:   self.renderer:close()\nL132:   fn.win_gotoid(self.code.win)\nL133: end\nL134: \nL135: ---@return boolean\nL136: function Sidebar:focus()\nL137:   if self.view:is_open() then\nL138:     fn.win_gotoid(self.view.win)\nL139:     self.renderer:focus()\nL140:     return true\nL141:   end\nL142:   return false\nL143: end\nL144: \nL145: ---@param content string\nL146: ---@param jump? boolean\nL147: function Sidebar:update_content(content, jump)\nL148:   jump = jump or false\nL149: \nL150:   vim.defer_fn(function()\nL151:     api.nvim_set_option_value(\"modifiable\", true, { buf = self.view.buf })\nL152:     api.nvim_buf_set_lines(self.view.buf, 0, -1, false, vim.split(content, \"\\n\"))\nL153:     api.nvim_set_option_value(\"modifiable\", false, { buf = self.view.buf })\nL154:     api.nvim_set_option_value(\"filetype\", \"Avante\", { buf = self.view.buf })\nL155: \nL156:     -- Move to the bottom\nL157:     if jump then\nL158:       api.nvim_win_set_cursor(self.view.win, { api.nvim_buf_line_count(self.view.buf), 0 })\nL159:       api.nvim_set_current_win(self.code.win)\nL160:     else\nL161:       self.renderer:focus()\nL162:     end\nL163:   end, 0)\nL164: end\nL165: \nL166: local function parse_codeblocks(buf)\nL167:   local codeblocks = {}\nL168:   local in_codeblock = false\nL169:   local start_line = nil\nL170:   local lang = nil\nL171: \nL172:   local lines = api.nvim_buf_get_lines(buf, 0, -1, false)\nL173:   for i, line in ipairs(lines) do\nL174:     if line:match(\"^```\") then\nL175:       -- parse language\nL176:       local lang_ = line:match(\"^```(%w+)\")\nL177:       if in_codeblock and not lang_ then\nL178:         table.insert(codeblocks, { start_line = start_line, end_line = i - 1, lang = lang })\nL179:         in_codeblock = false\nL180:       elseif lang_ then\nL181:         lang = lang_\nL182:         start_line = i - 1\nL183:         in_codeblock = true\nL184:       end\nL185:     end\nL186:   end\nL187: \nL188:   return codeblocks\nL189: end\nL190: \nL191: ---@param codeblocks table<integer, any>\nL192: local function is_cursor_in_codeblock(codeblocks)\nL193:   local cursor_pos = api.nvim_win_get_cursor(0)\nL194:   local cursor_line = cursor_pos[1] - 1 -- 转换为 0-indexed 行号\nL195: \nL196:   for _, block in ipairs(codeblocks) do\nL197:     if cursor_line >= block.start_line and cursor_line <= block.end_line then\nL198:       return block\nL199:     end\nL200:   end\nL201: \nL202:   return nil\nL203: end\nL204: \nL205: local function prepend_line_number(content)\nL206:   local lines = vim.split(content, \"\\n\")\nL207:   local result = {}\nL208:   for i, line in ipairs(lines) do\nL209:     table.insert(result, \"L\" .. i .. \": \" .. line)\nL210:   end\nL211:   return table.concat(result, \"\\n\")\nL212: end\nL213: \nL214: local function extract_code_snippets(content)\nL215:   local snippets = {}\nL216:   local current_snippet = {}\nL217:   local in_code_block = false\nL218:   local lang, start_line, end_line\nL219:   local explanation = \"\"\nL220: \nL221:   for line in content:gmatch(\"[^\\r\\n]+\") do\nL222:     local start_line_str, end_line_str = line:match(\"^Replace lines: (%d+)-(%d+)\")\nL223:     if start_line_str ~= nil and end_line_str ~= nil then\nL224:       start_line = tonumber(start_line_str)\nL225:       end_line = tonumber(end_line_str)\nL226:     end\nL227:     if line:match(\"^```\") then\nL228:       if in_code_block then\nL229:         if start_line ~= nil and end_line ~= nil then\nL230:           table.insert(snippets, {\nL231:             range = { start_line, end_line },\nL232:             content = table.concat(current_snippet, \"\\n\"),\nL233:             lang = lang,\nL234:             explanation = explanation,\nL235:           })\nL236:         end\nL237:         current_snippet = {}\nL238:         start_line, end_line = nil, nil\nL239:         explanation = \"\"\nL240:         in_code_block = false\nL241:       else\nL242:         lang = line:match(\"^```(%w+)\")\nL243:         if not lang or lang == \"\" then\nL244:           lang = \"text\"\nL245:         end\nL246:         in_code_block = true\nL247:       end\nL248:     elseif in_code_block then\nL249:       table.insert(current_snippet, line)\nL250:     else\nL251:       explanation = explanation .. line .. \"\\n\"\nL252:     end\nL253:   end\nL254: \nL255:   return snippets\nL256: end\nL257: \nL258: -- Add a new function to display notifications\nL259: local function show_notification(message)\nL260:   vim.notify(message, vim.log.levels.INFO, {\nL261:     title = \"AI Assistant\",\nL262:     timeout = 3000,\nL263:   })\nL264: end\nL265: \nL266: -- Function to get the current project root directory\nL267: local function get_project_root()\nL268:   local current_file = fn.expand(\"%:p\")\nL269:   local current_dir = fn.fnamemodify(current_file, \":h\")\nL270:   local git_root = fn.systemlist(\"git -C \" .. fn.shellescape(current_dir) .. \" rev-parse --show-toplevel\")[1]\nL271:   return git_root or current_dir\nL272: end\nL273: \nL274: ---@param sidebar avante.Sidebar\nL275: local function get_chat_history_filename(sidebar)\nL276:   local code_buf_name = api.nvim_buf_get_name(sidebar.code.buf)\nL277:   local relative_path = fn.fnamemodify(code_buf_name, \":~:.\")\nL278:   -- Replace path separators with double underscores\nL279:   local path_with_separators = fn.substitute(relative_path, \"/\", \"__\", \"g\")\nL280:   -- Replace other non-alphanumeric characters with single underscores\nL281:   return fn.substitute(path_with_separators, \"[^A-Za-z0-9._]\", \"_\", \"g\")\nL282: end\nL283: \nL284: -- Function to get the chat history file path\nL285: local function get_chat_history_file(sidebar)\nL286:   local project_root = get_project_root()\nL287:   local filename = get_chat_history_filename(sidebar)\nL288:   local history_dir = Path:new(project_root, \".avante_chat_history\")\nL289:   return history_dir:joinpath(filename .. \".json\")\nL290: end\nL291: \nL292: -- Function to get current timestamp\nL293: local function get_timestamp()\nL294:   return os.date(\"%Y-%m-%d %H:%M:%S\")\nL295: end\nL296: \nL297: -- Function to load chat history\nL298: local function load_chat_history(sidebar)\nL299:   local history_file = get_chat_history_file(sidebar)\nL300:   if history_file:exists() then\nL301:     local content = history_file:read()\nL302:     return fn.json_decode(content)\nL", "requirement": "\n\n\n"}, {"timestamp": "2024-08-17 14:24:32", "response": "```lua\nL1: local View = require(\"avante.view\")\nL2: \nL3: local Path = require(\"plenary.path\")\nL4: local N = require(\"nui-components\")\nL5: local Renderer = require(\"nui-components.renderer\")\nL6: local diff = require(\"avante.diff\")\nL7: local config = require(\"avante.config\")\nL8: local ai_bot = require(\"avante.ai_bot\")\nL9: local api = vim.api\nL10: local fn = vim.fn\nL11: \nL12: local CODEBLOCK_KEYBINDING_NAMESPACE = api.nvim_create_namespace(\"AVANTE_CODEBLOCK_KEYBINDING\")\nL13: local PRIORITY = vim.highlight.priorities.user\nL14: \nL15: ---@class avante.Sidebar\nL16: local Sidebar = {}\nL17: \nL18: ---@class avante.SidebarState\nL19: ---@field win integer\nL20: ---@field buf integer\nL21: \nL22: ---@class avante.Sidebar\nL23: ---@field id integer\nL24: ---@field view avante.View\nL25: ---@field code avante.SidebarState\nL26: ---@field renderer NuiRenderer\nL27: \nL28: function Sidebar:new(id)\nL29:   return setmetatable({\nL30:     id = id,\nL31:     code = { buf = 0, win = 0 },\nL32:     view = View:new(),\nL33:     renderer = nil,\nL34:   }, { __index = Sidebar })\nL35: end\nL36: \nL37: function Sidebar:destroy()\nL38:   self.view = nil\nL39:   self.code = nil\nL40:   self.renderer = nil\nL41: end\nL42: \nL43: function Sidebar:reset()\nL44:   self.code = { buf = 0, win = 0 }\nL45: end\nL46: \nL47: function Sidebar:open()\nL48:   if not self.view:is_open() then\nL49:     self:intialize()\nL50:     self:render()\nL51:   else\nL52:     self:focus()\nL53:   end\nL54:   return self\nL55: end\nL56: \nL57: function Sidebar:toggle()\nL58:   if self.view:is_open() then\nL59:     self:close()\nL60:     return false\nL61:   else\nL62:     self:open()\nL63:     return true\nL64:   end\nL65: end\nL66: \nL67: function Sidebar:has_code_win()\nL68:   return self.code.win\nL69:       and self.code.buf\nL70:       and self.code.win ~= 0\nL71:       and self.code.buf ~= 0\nL72:       and api.nvim_win_is_valid(self.code.win)\nL73:       and api.nvim_buf_is_valid(self.code.buf)\nL74: end\nL75: \nL76: function Sidebar:focus_code()\nL77:   if self:has_code_win() then\nL78:     fn.win_gotoid(self.code.win)\nL79:     return true\nL80:   end\nL81:   return false\nL82: end\nL83: \nL84: function Sidebar:focus_toggle()\nL85:   if self.view:is_open() and self:has_code_win() then\nL86:     local winid = fn.win_getid()\nL87:     if winid == self.code.win then\nL88:       fn.win_gotoid(self.view.win)\nL89:     else\nL90:       fn.win_gotoid(self.code.win)\nL91:     end\nL92:     return true\nL93:   end\nL94:   return false\nL95: end\nL96: \nL97: local get_renderer_size_and_position = function()\nL98:   local renderer_width = math.ceil(vim.o.columns * 0.3)\nL99:   local renderer_height = vim.o.lines\nL100:   local renderer_position = vim.o.columns - renderer_width\nL101:   return renderer_width, renderer_height, renderer_position\nL102: end\nL103: \nL104: function Sidebar:intialize()\nL105:   self.code.win = api.nvim_get_current_win()\nL106:   self.code.buf = api.nvim_get_current_buf()\nL107: \nL108:   local split_command = \"botright vs\"\nL109:   local renderer_width, renderer_height, renderer_position = get_renderer_size_and_position()\nL110: \nL111:   self.view:setup(split_command, renderer_width)\nL112: \nL113:   local winid = fn.bufwinid(self.view.buf)\nL114:   --- setup coord\nL115:   self.renderer = Renderer.create({\nL116:     width = api.nvim_win_get_width(winid),\nL117:     height = renderer_height,\nL118:     position = renderer_position,\nL119:     relative = { type = \"win\", winid = winid },\nL120:   })\nL121: \nL122:   -- reset states when buffer is closed\nL123:   api.nvim_buf_attach(self.code.buf, false, {\nL124:     on_detach = function(_, _)\nL125:       self:reset()\nL126:     end,\nL127:   })\nL128: end\nL129: \nL130: function Sidebar:close()\nL131:   self.renderer:close()\nL132:   fn.win_gotoid(self.code.win)\nL133: end\nL134: \nL135: ---@return boolean\nL136: function Sidebar:focus()\nL137:   if self.view:is_open() then\nL138:     fn.win_gotoid(self.view.win)\nL139:     self.renderer:focus()\nL140:     return true\nL141:   end\nL142:   return false\nL143: end\nL144: \nL145: ---@param content string\nL146: ---@param jump? boolean\nL147: function Sidebar:update_content(content, jump)\nL148:   jump = jump or false\nL149: \nL150:   vim.defer_fn(function()\nL151:     api.nvim_set_option_value(\"modifiable\", true, { buf = self.view.buf })\nL152:     api.nvim_buf_set_lines(self.view.buf, 0, -1, false, vim.split(content, \"\\n\"))\nL153:     api.nvim_set_option_value(\"modifiable\", false, { buf = self.view.buf })\nL154:     api.nvim_set_option_value(\"filetype\", \"Avante\", { buf = self.view.buf })\nL155: \nL156:     -- Move to the bottom\nL157:     if jump then\nL158:       api.nvim_win_set_cursor(self.view.win, { api.nvim_buf_line_count(self.view.buf), 0 })\nL159:       api.nvim_set_current_win(self.code.win)\nL160:     else\nL161:       self.renderer:focus()\nL162:     end\nL163:   end, 0)\nL164: end\nL165: \nL166: local function parse_codeblocks(buf)\nL167:   local codeblocks = {}\nL168:   local in_codeblock = false\nL169:   local start_line = nil\nL170:   local lang = nil\nL171: \nL172:   local lines = api.nvim_buf_get_lines(buf, 0, -1, false)\nL173:   for i, line in ipairs(lines) do\nL174:     if line:match(\"^```\") then\nL175:       -- parse language\nL176:       local lang_ = line:match(\"^```(%w+)\")\nL177:       if in_codeblock and not lang_ then\nL178:         table.insert(codeblocks, { start_line = start_line, end_line = i - 1, lang = lang })\nL179:         in_codeblock = false\nL180:       elseif lang_ then\nL181:         lang = lang_\nL182:         start_line = i - 1\nL183:         in_codeblock = true\nL184:       end\nL185:     end\nL186:   end\nL187: \nL188:   return codeblocks\nL189: end\nL190: \nL191: ---@param codeblocks table<integer, any>\nL192: local function is_cursor_in_codeblock(codeblocks)\nL193:   local cursor_pos = api.nvim_win_get_cursor(0)\nL194:   local cursor_line = cursor_pos[1] - 1 -- 转换为 0-indexed 行号\nL195: \nL196:   for _, block in ipairs(codeblocks) do\nL197:     if cursor_line >= block.start_line and cursor_line <= block.end_line then\nL198:       return block\nL199:     end\nL200:   end\nL201: \nL202:   return nil\nL203: end\nL204: \nL205: local function prepend_line_number(content)\nL206:   local lines = vim.split(content, \"\\n\")\nL207:   local result = {}\nL208:   for i, line in ipairs(lines) do\nL209:     table.insert(result, \"L\" .. i .. \": \" .. line)\nL210:   end\nL211:   return table.concat(result, \"\\n\")\nL212: end\nL213: \nL214: local function extract_code_snippets(content)\nL215:   local snippets = {}\nL216:   local current_snippet = {}\nL217:   local in_code_block = false\nL218:   local lang, start_line, end_line\nL219:   local explanation = \"\"\nL220: \nL221:   for line in content:gmatch(\"[^\\r\\n]+\") do\nL222:     local start_line_str, end_line_str = line:match(\"^Replace lines: (%d+)-(%d+)\")\nL223:     if start_line_str ~= nil and end_line_str ~= nil then\nL224:       start_line = tonumber(start_line_str)\nL225:       end_line = tonumber(end_line_str)\nL226:     end\nL227:     if line:match(\"^```\") then\nL228:       if in_code_block then\nL229:         if start_line ~= nil and end_line ~= nil then\nL230:           table.insert(snippets, {\nL231:             range = { start_line, end_line },\nL232:             content = table.concat(current_snippet, \"\\n\"),\nL233:             lang = lang,\nL234:             explanation = explanation,\nL235:           })\nL236:         end\nL237:         current_snippet = {}\nL238:         start_line, end_line = nil, nil\nL239:         explanation = \"\"\nL240:         in_code_block = false\nL241:       else\nL242:         lang = line:match(\"^```(%w+)\")\nL243:         if not lang or lang == \"\" then\nL244:           lang = \"text\"\nL245:         end\nL246:         in_code_block = true\nL247:       end\nL248:     elseif in_code_block then\nL249:       table.insert(current_snippet, line)\nL250:     else\nL251:       explanation = explanation .. line .. \"\\n\"\nL252:     end\nL253:   end\nL254: \nL255:   return snippets\nL256: end\nL257: \nL258: -- Add a new function to display notifications\nL259: local function show_notification(message)\nL260:   vim.notify(message, vim.log.levels.INFO, {\nL261:     title = \"AI Assistant\",\nL262:     timeout = 3000,\nL263:   })\nL264: end\nL265: \nL266: -- Function to get the current project root directory\nL267: local function get_project_root()\nL268:   local current_file = fn.expand(\"%:p\")\nL269:   local current_dir = fn.fnamemodify(current_file, \":h\")\nL270:   local git_root = fn.systemlist(\"git -C \" .. fn.shellescape(current_dir) .. \" rev-parse --show-toplevel\")[1]\nL271:   return git_root or current_dir\nL272: end\nL273: \nL274: ---@param sidebar avante.Sidebar\nL275: local function get_chat_history_filename(sidebar)\nL276:   local code_buf_name = api.nvim_buf_get_name(sidebar.code.buf)\nL277:   local relative_path = fn.fnamemodify(code_buf_name, \":~:.\")\nL278:   -- Replace path separators with double underscores\nL279:   local path_with_separators = fn.substitute(relative_path, \"/\", \"__\", \"g\")\nL280:   -- Replace other non-alphanumeric characters with single underscores\nL281:   return fn.substitute(path_with_separators, \"[^A-Za-z0-9._]\", \"_\", \"g\")\nL282: end\nL283: \nL284: -- Function to get the chat history file path\nL285: local function get_chat_history_file(sidebar)\nL286:   local project_root = get_project_root()\nL287:   local filename = get_chat_history_filename(sidebar)\nL288:   local history_dir = Path:new(project_root, \".avante_chat_history\")\nL289:   return history_dir:joinpath(filename .. \".json\")\nL290: end\nL291: \nL292: -- Function to get current timestamp\nL293: local function get_timestamp()\nL294:   return os.date(\"%Y-%m-%d %H:%M:%S\")\nL295: end\nL296: \nL297: -- Function to load chat history\nL298: local function load_chat_history(sidebar)\nL299:   local history_file = get_chat_history_file(sidebar)\nL300:   if history_file:exists() then\nL301:     local content = history_file:read()\nL302:     return fn.json_decode(content)\nL", "requirement": "\n\n\n\n\n\n\n"}, {"timestamp": "2024-08-17 14:24:31", "response": "```lua\nL1: local View = require(\"avante.view\")\nL2: \nL3: local Path = require(\"plenary.path\")\nL4: local N = require(\"nui-components\")\nL5: local Renderer = require(\"nui-components.renderer\")\nL6: local diff = require(\"avante.diff\")\nL7: local config = require(\"avante.config\")\nL8: local ai_bot = require(\"avante.ai_bot\")\nL9: local api = vim.api\nL10: local fn = vim.fn\nL11: \nL12: local CODEBLOCK_KEYBINDING_NAMESPACE = api.nvim_create_namespace(\"AVANTE_CODEBLOCK_KEYBINDING\")\nL13: local PRIORITY = vim.highlight.priorities.user\nL14: \nL15: ---@class avante.Sidebar\nL16: local Sidebar = {}\nL17: \nL18: ---@class avante.SidebarState\nL19: ---@field win integer\nL20: ---@field buf integer\nL21: \nL22: ---@class avante.Sidebar\nL23: ---@field id integer\nL24: ---@field view avante.View\nL25: ---@field code avante.SidebarState\nL26: ---@field renderer NuiRenderer\nL27: \nL28: function Sidebar:new(id)\nL29:   return setmetatable({\nL30:     id = id,\nL31:     code = { buf = 0, win = 0 },\nL32:     view = View:new(),\nL33:     renderer = nil,\nL34:   }, { __index = Sidebar })\nL35: end\nL36: \nL37: function Sidebar:destroy()\nL38:   self.view = nil\nL39:   self.code = nil\nL40:   self.renderer = nil\nL41: end\nL42: \nL43: function Sidebar:reset()\nL44:   self.code = { buf = 0, win = 0 }\nL45: end\nL46: \nL47: function Sidebar:open()\nL48:   if not self.view:is_open() then\nL49:     self:intialize()\nL50:     self:render()\nL51:   else\nL52:     self:focus()\nL53:   end\nL54:   return self\nL55: end\nL56: \nL57: function Sidebar:toggle()\nL58:   if self.view:is_open() then\nL59:     self:close()\nL60:     return false\nL61:   else\nL62:     self:open()\nL63:     return true\nL64:   end\nL65: end\nL66: \nL67: function Sidebar:has_code_win()\nL68:   return self.code.win\nL69:       and self.code.buf\nL70:       and self.code.win ~= 0\nL71:       and self.code.buf ~= 0\nL72:       and api.nvim_win_is_valid(self.code.win)\nL73:       and api.nvim_buf_is_valid(self.code.buf)\nL74: end\nL75: \nL76: function Sidebar:focus_code()\nL77:   if self:has_code_win() then\nL78:     fn.win_gotoid(self.code.win)\nL79:     return true\nL80:   end\nL81:   return false\nL82: end\nL83: \nL84: function Sidebar:focus_toggle()\nL85:   if self.view:is_open() and self:has_code_win() then\nL86:     local winid = fn.win_getid()\nL87:     if winid == self.code.win then\nL88:       fn.win_gotoid(self.view.win)\nL89:     else\nL90:       fn.win_gotoid(self.code.win)\nL91:     end\nL92:     return true\nL93:   end\nL94:   return false\nL95: end\nL96: \nL97: local get_renderer_size_and_position = function()\nL98:   local renderer_width = math.ceil(vim.o.columns * 0.3)\nL99:   local renderer_height = vim.o.lines\nL100:   local renderer_position = vim.o.columns - renderer_width\nL101:   return renderer_width, renderer_height, renderer_position\nL102: end\nL103: \nL104: function Sidebar:intialize()\nL105:   self.code.win = api.nvim_get_current_win()\nL106:   self.code.buf = api.nvim_get_current_buf()\nL107: \nL108:   local split_command = \"botright vs\"\nL109:   local renderer_width, renderer_height, renderer_position = get_renderer_size_and_position()\nL110: \nL111:   self.view:setup(split_command, renderer_width)\nL112: \nL113:   local winid = fn.bufwinid(self.view.buf)\nL114:   --- setup coord\nL115:   self.renderer = Renderer.create({\nL116:     width = api.nvim_win_get_width(winid),\nL117:     height = renderer_height,\nL118:     position = renderer_position,\nL119:     relative = { type = \"win\", winid = winid },\nL120:   })\nL121: \nL122:   -- reset states when buffer is closed\nL123:   api.nvim_buf_attach(self.code.buf, false, {\nL124:     on_detach = function(_, _)\nL125:       self:reset()\nL126:     end,\nL127:   })\nL128: end\nL129: \nL130: function Sidebar:close()\nL131:   self.renderer:close()\nL132:   fn.win_gotoid(self.code.win)\nL133: end\nL134: \nL135: ---@return boolean\nL136: function Sidebar:focus()\nL137:   if self.view:is_open() then\nL138:     fn.win_gotoid(self.view.win)\nL139:     self.renderer:focus()\nL140:     return true\nL141:   end\nL142:   return false\nL143: end\nL144: \nL145: ---@param content string\nL146: ---@param jump? boolean\nL147: function Sidebar:update_content(content, jump)\nL148:   jump = jump or false\nL149: \nL150:   vim.defer_fn(function()\nL151:     api.nvim_set_option_value(\"modifiable\", true, { buf = self.view.buf })\nL152:     api.nvim_buf_set_lines(self.view.buf, 0, -1, false, vim.split(content, \"\\n\"))\nL153:     api.nvim_set_option_value(\"modifiable\", false, { buf = self.view.buf })\nL154:     api.nvim_set_option_value(\"filetype\", \"Avante\", { buf = self.view.buf })\nL155: \nL156:     -- Move to the bottom\nL157:     if jump then\nL158:       api.nvim_win_set_cursor(self.view.win, { api.nvim_buf_line_count(self.view.buf), 0 })\nL159:       api.nvim_set_current_win(self.code.win)\nL160:     else\nL161:       self.renderer:focus()\nL162:     end\nL163:   end, 0)\nL164: end\nL165: \nL166: local function parse_codeblocks(buf)\nL167:   local codeblocks = {}\nL168:   local in_codeblock = false\nL169:   local start_line = nil\nL170:   local lang = nil\nL171: \nL172:   local lines = api.nvim_buf_get_lines(buf, 0, -1, false)\nL173:   for i, line in ipairs(lines) do\nL174:     if line:match(\"^```\") then\nL175:       -- parse language\nL176:       local lang_ = line:match(\"^```(%w+)\")\nL177:       if in_codeblock and not lang_ then\nL178:         table.insert(codeblocks, { start_line = start_line, end_line = i - 1, lang = lang })\nL179:         in_codeblock = false\nL180:       elseif lang_ then\nL181:         lang = lang_\nL182:         start_line = i - 1\nL183:         in_codeblock = true\nL184:       end\nL185:     end\nL186:   end\nL187: \nL188:   return codeblocks\nL189: end\nL190: \nL191: ---@param codeblocks table<integer, any>\nL192: local function is_cursor_in_codeblock(codeblocks)\nL193:   local cursor_pos = api.nvim_win_get_cursor(0)\nL194:   local cursor_line = cursor_pos[1] - 1 -- 转换为 0-indexed 行号\nL195: \nL196:   for _, block in ipairs(codeblocks) do\nL197:     if cursor_line >= block.start_line and cursor_line <= block.end_line then\nL198:       return block\nL199:     end\nL200:   end\nL201: \nL202:   return nil\nL203: end\nL204: \nL205: local function prepend_line_number(content)\nL206:   local lines = vim.split(content, \"\\n\")\nL207:   local result = {}\nL208:   for i, line in ipairs(lines) do\nL209:     table.insert(result, \"L\" .. i .. \": \" .. line)\nL210:   end\nL211:   return table.concat(result, \"\\n\")\nL212: end\nL213: \nL214: local function extract_code_snippets(content)\nL215:   local snippets = {}\nL216:   local current_snippet = {}\nL217:   local in_code_block = false\nL218:   local lang, start_line, end_line\nL219:   local explanation = \"\"\nL220: \nL221:   for line in content:gmatch(\"[^\\r\\n]+\") do\nL222:     local start_line_str, end_line_str = line:match(\"^Replace lines: (%d+)-(%d+)\")\nL223:     if start_line_str ~= nil and end_line_str ~= nil then\nL224:       start_line = tonumber(start_line_str)\nL225:       end_line = tonumber(end_line_str)\nL226:     end\nL227:     if line:match(\"^```\") then\nL228:       if in_code_block then\nL229:         if start_line ~= nil and end_line ~= nil then\nL230:           table.insert(snippets, {\nL231:             range = { start_line, end_line },\nL232:             content = table.concat(current_snippet, \"\\n\"),\nL233:             lang = lang,\nL234:             explanation = explanation,\nL235:           })\nL236:         end\nL237:         current_snippet = {}\nL238:         start_line, end_line = nil, nil\nL239:         explanation = \"\"\nL240:         in_code_block = false\nL241:       else\nL242:         lang = line:match(\"^```(%w+)\")\nL243:         if not lang or lang == \"\" then\nL244:           lang = \"text\"\nL245:         end\nL246:         in_code_block = true\nL247:       end\nL248:     elseif in_code_block then\nL249:       table.insert(current_snippet, line)\nL250:     else\nL251:       explanation = explanation .. line .. \"\\n\"\nL252:     end\nL253:   end\nL254: \nL255:   return snippets\nL256: end\nL257: \nL258: -- Add a new function to display notifications\nL259: local function show_notification(message)\nL260:   vim.notify(message, vim.log.levels.INFO, {\nL261:     title = \"AI Assistant\",\nL262:     timeout = 3000,\nL263:   })\nL264: end\nL265: \nL266: -- Function to get the current project root directory\nL267: local function get_project_root()\nL268:   local current_file = fn.expand(\"%:p\")\nL269:   local current_dir = fn.fnamemodify(current_file, \":h\")\nL270:   local git_root = fn.systemlist(\"git -C \" .. fn.shellescape(current_dir) .. \" rev-parse --show-toplevel\")[1]\nL271:   return git_root or current_dir\nL272: end\nL273: \nL274: ---@param sidebar avante.Sidebar\nL275: local function get_chat_history_filename(sidebar)\nL276:   local code_buf_name = api.nvim_buf_get_name(sidebar.code.buf)\nL277:   local relative_path = fn.fnamemodify(code_buf_name, \":~:.\")\nL278:   -- Replace path separators with double underscores\nL279:   local path_with_separators = fn.substitute(relative_path, \"/\", \"__\", \"g\")\nL280:   -- Replace other non-alphanumeric characters with single underscores\nL281:   return fn.substitute(path_with_separators, \"[^A-Za-z0-9._]\", \"_\", \"g\")\nL282: end\nL283: \nL284: -- Function to get the chat history file path\nL285: local function get_chat_history_file(sidebar)\nL286:   local project_root = get_project_root()\nL287:   local filename = get_chat_history_filename(sidebar)\nL288:   local history_dir = Path:new(project_root, \".avante_chat_history\")\nL289:   return history_dir:joinpath(filename .. \".json\")\nL290: end\nL291: \nL292: -- Function to get current timestamp\nL293: local function get_timestamp()\nL294:   return os.date(\"%Y-%m-%d %H:%M:%S\")\nL295: end\nL296: \nL297: -- Function to load chat history\nL298: local function load_chat_history(sidebar)\nL299:   local history_file = get_chat_history_file(sidebar)\nL300:   if history_file:exists() then\nL301:     local content = history_file:read()\nL302:     return fn.json_decode(content)\nL", "requirement": "\n\n\n\n\n"}, {"timestamp": "2024-08-17 14:24:30", "response": "```lua\nL1: local View = require(\"avante.view\")\nL2: \nL3: local Path = require(\"plenary.path\")\nL4: local N = require(\"nui-components\")\nL5: local Renderer = require(\"nui-components.renderer\")\nL6: local diff = require(\"avante.diff\")\nL7: local config = require(\"avante.config\")\nL8: local ai_bot = require(\"avante.ai_bot\")\nL9: local api = vim.api\nL10: local fn = vim.fn\nL11: \nL12: local CODEBLOCK_KEYBINDING_NAMESPACE = api.nvim_create_namespace(\"AVANTE_CODEBLOCK_KEYBINDING\")\nL13: local PRIORITY = vim.highlight.priorities.user\nL14: \nL15: ---@class avante.Sidebar\nL16: local Sidebar = {}\nL17: \nL18: ---@class avante.SidebarState\nL19: ---@field win integer\nL20: ---@field buf integer\nL21: \nL22: ---@class avante.Sidebar\nL23: ---@field id integer\nL24: ---@field view avante.View\nL25: ---@field code avante.SidebarState\nL26: ---@field renderer NuiRenderer\nL27: \nL28: function Sidebar:new(id)\nL29:   return setmetatable({\nL30:     id = id,\nL31:     code = { buf = 0, win = 0 },\nL32:     view = View:new(),\nL33:     renderer = nil,\nL34:   }, { __index = Sidebar })\nL35: end\nL36: \nL37: function Sidebar:destroy()\nL38:   self.view = nil\nL39:   self.code = nil\nL40:   self.renderer = nil\nL41: end\nL42: \nL43: function Sidebar:reset()\nL44:   self.code = { buf = 0, win = 0 }\nL45: end\nL46: \nL47: function Sidebar:open()\nL48:   if not self.view:is_open() then\nL49:     self:intialize()\nL50:     self:render()\nL51:   else\nL52:     self:focus()\nL53:   end\nL54:   return self\nL55: end\nL56: \nL57: function Sidebar:toggle()\nL58:   if self.view:is_open() then\nL59:     self:close()\nL60:     return false\nL61:   else\nL62:     self:open()\nL63:     return true\nL64:   end\nL65: end\nL66: \nL67: function Sidebar:has_code_win()\nL68:   return self.code.win\nL69:       and self.code.buf\nL70:       and self.code.win ~= 0\nL71:       and self.code.buf ~= 0\nL72:       and api.nvim_win_is_valid(self.code.win)\nL73:       and api.nvim_buf_is_valid(self.code.buf)\nL74: end\nL75: \nL76: function Sidebar:focus_code()\nL77:   if self:has_code_win() then\nL78:     fn.win_gotoid(self.code.win)\nL79:     return true\nL80:   end\nL81:   return false\nL82: end\nL83: \nL84: function Sidebar:focus_toggle()\nL85:   if self.view:is_open() and self:has_code_win() then\nL86:     local winid = fn.win_getid()\nL87:     if winid == self.code.win then\nL88:       fn.win_gotoid(self.view.win)\nL89:     else\nL90:       fn.win_gotoid(self.code.win)\nL91:     end\nL92:     return true\nL93:   end\nL94:   return false\nL95: end\nL96: \nL97: local get_renderer_size_and_position = function()\nL98:   local renderer_width = math.ceil(vim.o.columns * 0.3)\nL99:   local renderer_height = vim.o.lines\nL100:   local renderer_position = vim.o.columns - renderer_width\nL101:   return renderer_width, renderer_height, renderer_position\nL102: end\nL103: \nL104: function Sidebar:intialize()\nL105:   self.code.win = api.nvim_get_current_win()\nL106:   self.code.buf = api.nvim_get_current_buf()\nL107: \nL108:   local split_command = \"botright vs\"\nL109:   local renderer_width, renderer_height, renderer_position = get_renderer_size_and_position()\nL110: \nL111:   self.view:setup(split_command, renderer_width)\nL112: \nL113:   local winid = fn.bufwinid(self.view.buf)\nL114:   --- setup coord\nL115:   self.renderer = Renderer.create({\nL116:     width = api.nvim_win_get_width(winid),\nL117:     height = renderer_height,\nL118:     position = renderer_position,\nL119:     relative = { type = \"win\", winid = winid },\nL120:   })\nL121: \nL122:   -- reset states when buffer is closed\nL123:   api.nvim_buf_attach(self.code.buf, false, {\nL124:     on_detach = function(_, _)\nL125:       self:reset()\nL126:     end,\nL127:   })\nL128: end\nL129: \nL130: function Sidebar:close()\nL131:   self.renderer:close()\nL132:   fn.win_gotoid(self.code.win)\nL133: end\nL134: \nL135: ---@return boolean\nL136: function Sidebar:focus()\nL137:   if self.view:is_open() then\nL138:     fn.win_gotoid(self.view.win)\nL139:     self.renderer:focus()\nL140:     return true\nL141:   end\nL142:   return false\nL143: end\nL144: \nL145: ---@param content string\nL146: ---@param jump? boolean\nL147: function Sidebar:update_content(content, jump)\nL148:   jump = jump or false\nL149: \nL150:   vim.defer_fn(function()\nL151:     api.nvim_set_option_value(\"modifiable\", true, { buf = self.view.buf })\nL152:     api.nvim_buf_set_lines(self.view.buf, 0, -1, false, vim.split(content, \"\\n\"))\nL153:     api.nvim_set_option_value(\"modifiable\", false, { buf = self.view.buf })\nL154:     api.nvim_set_option_value(\"filetype\", \"Avante\", { buf = self.view.buf })\nL155: \nL156:     -- Move to the bottom\nL157:     if jump then\nL158:       api.nvim_win_set_cursor(self.view.win, { api.nvim_buf_line_count(self.view.buf), 0 })\nL159:       api.nvim_set_current_win(self.code.win)\nL160:     else\nL161:       self.renderer:focus()\nL162:     end\nL163:   end, 0)\nL164: end\nL165: \nL166: local function parse_codeblocks(buf)\nL167:   local codeblocks = {}\nL168:   local in_codeblock = false\nL169:   local start_line = nil\nL170:   local lang = nil\nL171: \nL172:   local lines = api.nvim_buf_get_lines(buf, 0, -1, false)\nL173:   for i, line in ipairs(lines) do\nL174:     if line:match(\"^```\") then\nL175:       -- parse language\nL176:       local lang_ = line:match(\"^```(%w+)\")\nL177:       if in_codeblock and not lang_ then\nL178:         table.insert(codeblocks, { start_line = start_line, end_line = i - 1, lang = lang })\nL179:         in_codeblock = false\nL180:       elseif lang_ then\nL181:         lang = lang_\nL182:         start_line = i - 1\nL183:         in_codeblock = true\nL184:       end\nL185:     end\nL186:   end\nL187: \nL188:   return codeblocks\nL189: end\nL190: \nL191: ---@param codeblocks table<integer, any>\nL192: local function is_cursor_in_codeblock(codeblocks)\nL193:   local cursor_pos = api.nvim_win_get_cursor(0)\nL194:   local cursor_line = cursor_pos[1] - 1 -- 转换为 0-indexed 行号\nL195: \nL196:   for _, block in ipairs(codeblocks) do\nL197:     if cursor_line >= block.start_line and cursor_line <= block.end_line then\nL198:       return block\nL199:     end\nL200:   end\nL201: \nL202:   return nil\nL203: end\nL204: \nL205: local function prepend_line_number(content)\nL206:   local lines = vim.split(content, \"\\n\")\nL207:   local result = {}\nL208:   for i, line in ipairs(lines) do\nL209:     table.insert(result, \"L\" .. i .. \": \" .. line)\nL210:   end\nL211:   return table.concat(result, \"\\n\")\nL212: end\nL213: \nL214: local function extract_code_snippets(content)\nL215:   local snippets = {}\nL216:   local current_snippet = {}\nL217:   local in_code_block = false\nL218:   local lang, start_line, end_line\nL219:   local explanation = \"\"\nL220: \nL221:   for line in content:gmatch(\"[^\\r\\n]+\") do\nL222:     local start_line_str, end_line_str = line:match(\"^Replace lines: (%d+)-(%d+)\")\nL223:     if start_line_str ~= nil and end_line_str ~= nil then\nL224:       start_line = tonumber(start_line_str)\nL225:       end_line = tonumber(end_line_str)\nL226:     end\nL227:     if line:match(\"^```\") then\nL228:       if in_code_block then\nL229:         if start_line ~= nil and end_line ~= nil then\nL230:           table.insert(snippets, {\nL231:             range = { start_line, end_line },\nL232:             content = table.concat(current_snippet, \"\\n\"),\nL233:             lang = lang,\nL234:             explanation = explanation,\nL235:           })\nL236:         end\nL237:         current_snippet = {}\nL238:         start_line, end_line = nil, nil\nL239:         explanation = \"\"\nL240:         in_code_block = false\nL241:       else\nL242:         lang = line:match(\"^```(%w+)\")\nL243:         if not lang or lang == \"\" then\nL244:           lang = \"text\"\nL245:         end\nL246:         in_code_block = true\nL247:       end\nL248:     elseif in_code_block then\nL249:       table.insert(current_snippet, line)\nL250:     else\nL251:       explanation = explanation .. line .. \"\\n\"\nL252:     end\nL253:   end\nL254: \nL255:   return snippets\nL256: end\nL257: \nL258: -- Add a new function to display notifications\nL259: local function show_notification(message)\nL260:   vim.notify(message, vim.log.levels.INFO, {\nL261:     title = \"AI Assistant\",\nL262:     timeout = 3000,\nL263:   })\nL264: end\nL265: \nL266: -- Function to get the current project root directory\nL267: local function get_project_root()\nL268:   local current_file = fn.expand(\"%:p\")\nL269:   local current_dir = fn.fnamemodify(current_file, \":h\")\nL270:   local git_root = fn.systemlist(\"git -C \" .. fn.shellescape(current_dir) .. \" rev-parse --show-toplevel\")[1]\nL271:   return git_root or current_dir\nL272: end\nL273: \nL274: ---@param sidebar avante.Sidebar\nL275: local function get_chat_history_filename(sidebar)\nL276:   local code_buf_name = api.nvim_buf_get_name(sidebar.code.buf)\nL277:   local relative_path = fn.fnamemodify(code_buf_name, \":~:.\")\nL278:   -- Replace path separators with double underscores\nL279:   local path_with_separators = fn.substitute(relative_path, \"/\", \"__\", \"g\")\nL280:   -- Replace other non-alphanumeric characters with single underscores\nL281:   return fn.substitute(path_with_separators, \"[^A-Za-z0-9._]\", \"_\", \"g\")\nL282: end\nL283: \nL284: -- Function to get the chat history file path\nL285: local function get_chat_history_file(sidebar)\nL286:   local project_root = get_project_root()\nL287:   local filename = get_chat_history_filename(sidebar)\nL288:   local history_dir = Path:new(project_root, \".avante_chat_history\")\nL289:   return history_dir:joinpath(filename .. \".json\")\nL290: end\nL291: \nL292: -- Function to get current timestamp\nL293: local function get_timestamp()\nL294:   return os.date(\"%Y-%m-%d %H:%M:%S\")\nL295: end\nL296: \nL297: -- Function to load chat history\nL298: local function load_chat_history(sidebar)\nL299:   local history_file = get_chat_history_file(sidebar)\nL300:   if history_file:exists() then\nL301:     local content = history_file:read()\nL302:     return fn.json_decode(content)\nL", "requirement": "\n"}, {"timestamp": "2024-08-17 14:24:31", "response": "```lua\nL1: local View = require(\"avante.view\")\nL2: \nL3: local Path = require(\"plenary.path\")\nL4: local N = require(\"nui-components\")\nL5: local Renderer = require(\"nui-components.renderer\")\nL6: local diff = require(\"avante.diff\")\nL7: local config = require(\"avante.config\")\nL8: local ai_bot = require(\"avante.ai_bot\")\nL9: local api = vim.api\nL10: local fn = vim.fn\nL11: \nL12: local CODEBLOCK_KEYBINDING_NAMESPACE = api.nvim_create_namespace(\"AVANTE_CODEBLOCK_KEYBINDING\")\nL13: local PRIORITY = vim.highlight.priorities.user\nL14: \nL15: ---@class avante.Sidebar\nL16: local Sidebar = {}\nL17: \nL18: ---@class avante.SidebarState\nL19: ---@field win integer\nL20: ---@field buf integer\nL21: \nL22: ---@class avante.Sidebar\nL23: ---@field id integer\nL24: ---@field view avante.View\nL25: ---@field code avante.SidebarState\nL26: ---@field renderer NuiRenderer\nL27: \nL28: function Sidebar:new(id)\nL29:   return setmetatable({\nL30:     id = id,\nL31:     code = { buf = 0, win = 0 },\nL32:     view = View:new(),\nL33:     renderer = nil,\nL34:   }, { __index = Sidebar })\nL35: end\nL36: \nL37: function Sidebar:destroy()\nL38:   self.view = nil\nL39:   self.code = nil\nL40:   self.renderer = nil\nL41: end\nL42: \nL43: function Sidebar:reset()\nL44:   self.code = { buf = 0, win = 0 }\nL45: end\nL46: \nL47: function Sidebar:open()\nL48:   if not self.view:is_open() then\nL49:     self:intialize()\nL50:     self:render()\nL51:   else\nL52:     self:focus()\nL53:   end\nL54:   return self\nL55: end\nL56: \nL57: function Sidebar:toggle()\nL58:   if self.view:is_open() then\nL59:     self:close()\nL60:     return false\nL61:   else\nL62:     self:open()\nL63:     return true\nL64:   end\nL65: end\nL66: \nL67: function Sidebar:has_code_win()\nL68:   return self.code.win\nL69:       and self.code.buf\nL70:       and self.code.win ~= 0\nL71:       and self.code.buf ~= 0\nL72:       and api.nvim_win_is_valid(self.code.win)\nL73:       and api.nvim_buf_is_valid(self.code.buf)\nL74: end\nL75: \nL76: function Sidebar:focus_code()\nL77:   if self:has_code_win() then\nL78:     fn.win_gotoid(self.code.win)\nL79:     return true\nL80:   end\nL81:   return false\nL82: end\nL83: \nL84: function Sidebar:focus_toggle()\nL85:   if self.view:is_open() and self:has_code_win() then\nL86:     local winid = fn.win_getid()\nL87:     if winid == self.code.win then\nL88:       fn.win_gotoid(self.view.win)\nL89:     else\nL90:       fn.win_gotoid(self.code.win)\nL91:     end\nL92:     return true\nL93:   end\nL94:   return false\nL95: end\nL96: \nL97: local get_renderer_size_and_position = function()\nL98:   local renderer_width = math.ceil(vim.o.columns * 0.3)\nL99:   local renderer_height = vim.o.lines\nL100:   local renderer_position = vim.o.columns - renderer_width\nL101:   return renderer_width, renderer_height, renderer_position\nL102: end\nL103: \nL104: function Sidebar:intialize()\nL105:   self.code.win = api.nvim_get_current_win()\nL106:   self.code.buf = api.nvim_get_current_buf()\nL107: \nL108:   local split_command = \"botright vs\"\nL109:   local renderer_width, renderer_height, renderer_position = get_renderer_size_and_position()\nL110: \nL111:   self.view:setup(split_command, renderer_width)\nL112: \nL113:   local winid = fn.bufwinid(self.view.buf)\nL114:   --- setup coord\nL115:   self.renderer = Renderer.create({\nL116:     width = api.nvim_win_get_width(winid),\nL117:     height = renderer_height,\nL118:     position = renderer_position,\nL119:     relative = { type = \"win\", winid = winid },\nL120:   })\nL121: \nL122:   -- reset states when buffer is closed\nL123:   api.nvim_buf_attach(self.code.buf, false, {\nL124:     on_detach = function(_, _)\nL125:       self:reset()\nL126:     end,\nL127:   })\nL128: end\nL129: \nL130: function Sidebar:close()\nL131:   self.renderer:close()\nL132:   fn.win_gotoid(self.code.win)\nL133: end\nL134: \nL135: ---@return boolean\nL136: function Sidebar:focus()\nL137:   if self.view:is_open() then\nL138:     fn.win_gotoid(self.view.win)\nL139:     self.renderer:focus()\nL140:     return true\nL141:   end\nL142:   return false\nL143: end\nL144: \nL145: ---@param content string\nL146: ---@param jump? boolean\nL147: function Sidebar:update_content(content, jump)\nL148:   jump = jump or false\nL149: \nL150:   vim.defer_fn(function()\nL151:     api.nvim_set_option_value(\"modifiable\", true, { buf = self.view.buf })\nL152:     api.nvim_buf_set_lines(self.view.buf, 0, -1, false, vim.split(content, \"\\n\"))\nL153:     api.nvim_set_option_value(\"modifiable\", false, { buf = self.view.buf })\nL154:     api.nvim_set_option_value(\"filetype\", \"Avante\", { buf = self.view.buf })\nL155: \nL156:     -- Move to the bottom\nL157:     if jump then\nL158:       api.nvim_win_set_cursor(self.view.win, { api.nvim_buf_line_count(self.view.buf), 0 })\nL159:       api.nvim_set_current_win(self.code.win)\nL160:     else\nL161:       self.renderer:focus()\nL162:     end\nL163:   end, 0)\nL164: end\nL165: \nL166: local function parse_codeblocks(buf)\nL167:   local codeblocks = {}\nL168:   local in_codeblock = false\nL169:   local start_line = nil\nL170:   local lang = nil\nL171: \nL172:   local lines = api.nvim_buf_get_lines(buf, 0, -1, false)\nL173:   for i, line in ipairs(lines) do\nL174:     if line:match(\"^```\") then\nL175:       -- parse language\nL176:       local lang_ = line:match(\"^```(%w+)\")\nL177:       if in_codeblock and not lang_ then\nL178:         table.insert(codeblocks, { start_line = start_line, end_line = i - 1, lang = lang })\nL179:         in_codeblock = false\nL180:       elseif lang_ then\nL181:         lang = lang_\nL182:         start_line = i - 1\nL183:         in_codeblock = true\nL184:       end\nL185:     end\nL186:   end\nL187: \nL188:   return codeblocks\nL189: end\nL190: \nL191: ---@param codeblocks table<integer, any>\nL192: local function is_cursor_in_codeblock(codeblocks)\nL193:   local cursor_pos = api.nvim_win_get_cursor(0)\nL194:   local cursor_line = cursor_pos[1] - 1 -- 转换为 0-indexed 行号\nL195: \nL196:   for _, block in ipairs(codeblocks) do\nL197:     if cursor_line >= block.start_line and cursor_line <= block.end_line then\nL198:       return block\nL199:     end\nL200:   end\nL201: \nL202:   return nil\nL203: end\nL204: \nL205: local function prepend_line_number(content)\nL206:   local lines = vim.split(content, \"\\n\")\nL207:   local result = {}\nL208:   for i, line in ipairs(lines) do\nL209:     table.insert(result, \"L\" .. i .. \": \" .. line)\nL210:   end\nL211:   return table.concat(result, \"\\n\")\nL212: end\nL213: \nL214: local function extract_code_snippets(content)\nL215:   local snippets = {}\nL216:   local current_snippet = {}\nL217:   local in_code_block = false\nL218:   local lang, start_line, end_line\nL219:   local explanation = \"\"\nL220: \nL221:   for line in content:gmatch(\"[^\\r\\n]+\") do\nL222:     local start_line_str, end_line_str = line:match(\"^Replace lines: (%d+)-(%d+)\")\nL223:     if start_line_str ~= nil and end_line_str ~= nil then\nL224:       start_line = tonumber(start_line_str)\nL225:       end_line = tonumber(end_line_str)\nL226:     end\nL227:     if line:match(\"^```\") then\nL228:       if in_code_block then\nL229:         if start_line ~= nil and end_line ~= nil then\nL230:           table.insert(snippets, {\nL231:             range = { start_line, end_line },\nL232:             content = table.concat(current_snippet, \"\\n\"),\nL233:             lang = lang,\nL234:             explanation = explanation,\nL235:           })\nL236:         end\nL237:         current_snippet = {}\nL238:         start_line, end_line = nil, nil\nL239:         explanation = \"\"\nL240:         in_code_block = false\nL241:       else\nL242:         lang = line:match(\"^```(%w+)\")\nL243:         if not lang or lang == \"\" then\nL244:           lang = \"text\"\nL245:         end\nL246:         in_code_block = true\nL247:       end\nL248:     elseif in_code_block then\nL249:       table.insert(current_snippet, line)\nL250:     else\nL251:       explanation = explanation .. line .. \"\\n\"\nL252:     end\nL253:   end\nL254: \nL255:   return snippets\nL256: end\nL257: \nL258: -- Add a new function to display notifications\nL259: local function show_notification(message)\nL260:   vim.notify(message, vim.log.levels.INFO, {\nL261:     title = \"AI Assistant\",\nL262:     timeout = 3000,\nL263:   })\nL264: end\nL265: \nL266: -- Function to get the current project root directory\nL267: local function get_project_root()\nL268:   local current_file = fn.expand(\"%:p\")\nL269:   local current_dir = fn.fnamemodify(current_file, \":h\")\nL270:   local git_root = fn.systemlist(\"git -C \" .. fn.shellescape(current_dir) .. \" rev-parse --show-toplevel\")[1]\nL271:   return git_root or current_dir\nL272: end\nL273: \nL274: ---@param sidebar avante.Sidebar\nL275: local function get_chat_history_filename(sidebar)\nL276:   local code_buf_name = api.nvim_buf_get_name(sidebar.code.buf)\nL277:   local relative_path = fn.fnamemodify(code_buf_name, \":~:.\")\nL278:   -- Replace path separators with double underscores\nL279:   local path_with_separators = fn.substitute(relative_path, \"/\", \"__\", \"g\")\nL280:   -- Replace other non-alphanumeric characters with single underscores\nL281:   return fn.substitute(path_with_separators, \"[^A-Za-z0-9._]\", \"_\", \"g\")\nL282: end\nL283: \nL284: -- Function to get the chat history file path\nL285: local function get_chat_history_file(sidebar)\nL286:   local project_root = get_project_root()\nL287:   local filename = get_chat_history_filename(sidebar)\nL288:   local history_dir = Path:new(project_root, \".avante_chat_history\")\nL289:   return history_dir:joinpath(filename .. \".json\")\nL290: end\nL291: \nL292: -- Function to get current timestamp\nL293: local function get_timestamp()\nL294:   return os.date(\"%Y-%m-%d %H:%M:%S\")\nL295: end\nL296: \nL297: -- Function to load chat history\nL298: local function load_chat_history(sidebar)\nL299:   local history_file = get_chat_history_file(sidebar)\nL300:   if history_file:exists() then\nL301:     local content = history_file:read()\nL302:     return fn.json_decode(content)\nL", "requirement": "\n\n\n\n\n\n"}, {"timestamp": "2024-08-17 14:24:32", "response": "```lua\nL1: local View = require(\"avante.view\")\nL2: \nL3: local Path = require(\"plenary.path\")\nL4: local N = require(\"nui-components\")\nL5: local Renderer = require(\"nui-components.renderer\")\nL6: local diff = require(\"avante.diff\")\nL7: local config = require(\"avante.config\")\nL8: local ai_bot = require(\"avante.ai_bot\")\nL9: local api = vim.api\nL10: local fn = vim.fn\nL11: \nL12: local CODEBLOCK_KEYBINDING_NAMESPACE = api.nvim_create_namespace(\"AVANTE_CODEBLOCK_KEYBINDING\")\nL13: local PRIORITY = vim.highlight.priorities.user\nL14: \nL15: ---@class avante.Sidebar\nL16: local Sidebar = {}\nL17: \nL18: ---@class avante.SidebarState\nL19: ---@field win integer\nL20: ---@field buf integer\nL21: \nL22: ---@class avante.Sidebar\nL23: ---@field id integer\nL24: ---@field view avante.View\nL25: ---@field code avante.SidebarState\nL26: ---@field renderer NuiRenderer\nL27: \nL28: function Sidebar:new(id)\nL29:   return setmetatable({\nL30:     id = id,\nL31:     code = { buf = 0, win = 0 },\nL32:     view = View:new(),\nL33:     renderer = nil,\nL34:   }, { __index = Sidebar })\nL35: end\nL36: \nL37: function Sidebar:destroy()\nL38:   self.view = nil\nL39:   self.code = nil\nL40:   self.renderer = nil\nL41: end\nL42: \nL43: function Sidebar:reset()\nL44:   self.code = { buf = 0, win = 0 }\nL45: end\nL46: \nL47: function Sidebar:open()\nL48:   if not self.view:is_open() then\nL49:     self:intialize()\nL50:     self:render()\nL51:   else\nL52:     self:focus()\nL53:   end\nL54:   return self\nL55: end\nL56: \nL57: function Sidebar:toggle()\nL58:   if self.view:is_open() then\nL59:     self:close()\nL60:     return false\nL61:   else\nL62:     self:open()\nL63:     return true\nL64:   end\nL65: end\nL66: \nL67: function Sidebar:has_code_win()\nL68:   return self.code.win\nL69:       and self.code.buf\nL70:       and self.code.win ~= 0\nL71:       and self.code.buf ~= 0\nL72:       and api.nvim_win_is_valid(self.code.win)\nL73:       and api.nvim_buf_is_valid(self.code.buf)\nL74: end\nL75: \nL76: function Sidebar:focus_code()\nL77:   if self:has_code_win() then\nL78:     fn.win_gotoid(self.code.win)\nL79:     return true\nL80:   end\nL81:   return false\nL82: end\nL83: \nL84: function Sidebar:focus_toggle()\nL85:   if self.view:is_open() and self:has_code_win() then\nL86:     local winid = fn.win_getid()\nL87:     if winid == self.code.win then\nL88:       fn.win_gotoid(self.view.win)\nL89:     else\nL90:       fn.win_gotoid(self.code.win)\nL91:     end\nL92:     return true\nL93:   end\nL94:   return false\nL95: end\nL96: \nL97: local get_renderer_size_and_position = function()\nL98:   local renderer_width = math.ceil(vim.o.columns * 0.3)\nL99:   local renderer_height = vim.o.lines\nL100:   local renderer_position = vim.o.columns - renderer_width\nL101:   return renderer_width, renderer_height, renderer_position\nL102: end\nL103: \nL104: function Sidebar:intialize()\nL105:   self.code.win = api.nvim_get_current_win()\nL106:   self.code.buf = api.nvim_get_current_buf()\nL107: \nL108:   local split_command = \"botright vs\"\nL109:   local renderer_width, renderer_height, renderer_position = get_renderer_size_and_position()\nL110: \nL111:   self.view:setup(split_command, renderer_width)\nL112: \nL113:   local winid = fn.bufwinid(self.view.buf)\nL114:   --- setup coord\nL115:   self.renderer = Renderer.create({\nL116:     width = api.nvim_win_get_width(winid),\nL117:     height = renderer_height,\nL118:     position = renderer_position,\nL119:     relative = { type = \"win\", winid = winid },\nL120:   })\nL121: \nL122:   -- reset states when buffer is closed\nL123:   api.nvim_buf_attach(self.code.buf, false, {\nL124:     on_detach = function(_, _)\nL125:       self:reset()\nL126:     end,\nL127:   })\nL128: end\nL129: \nL130: function Sidebar:close()\nL131:   self.renderer:close()\nL132:   fn.win_gotoid(self.code.win)\nL133: end\nL134: \nL135: ---@return boolean\nL136: function Sidebar:focus()\nL137:   if self.view:is_open() then\nL138:     fn.win_gotoid(self.view.win)\nL139:     self.renderer:focus()\nL140:     return true\nL141:   end\nL142:   return false\nL143: end\nL144: \nL145: ---@param content string\nL146: ---@param jump? boolean\nL147: function Sidebar:update_content(content, jump)\nL148:   jump = jump or false\nL149: \nL150:   vim.defer_fn(function()\nL151:     api.nvim_set_option_value(\"modifiable\", true, { buf = self.view.buf })\nL152:     api.nvim_buf_set_lines(self.view.buf, 0, -1, false, vim.split(content, \"\\n\"))\nL153:     api.nvim_set_option_value(\"modifiable\", false, { buf = self.view.buf })\nL154:     api.nvim_set_option_value(\"filetype\", \"Avante\", { buf = self.view.buf })\nL155: \nL156:     -- Move to the bottom\nL157:     if jump then\nL158:       api.nvim_win_set_cursor(self.view.win, { api.nvim_buf_line_count(self.view.buf), 0 })\nL159:       api.nvim_set_current_win(self.code.win)\nL160:     else\nL161:       self.renderer:focus()\nL162:     end\nL163:   end, 0)\nL164: end\nL165: \nL166: local function parse_codeblocks(buf)\nL167:   local codeblocks = {}\nL168:   local in_codeblock = false\nL169:   local start_line = nil\nL170:   local lang = nil\nL171: \nL172:   local lines = api.nvim_buf_get_lines(buf, 0, -1, false)\nL173:   for i, line in ipairs(lines) do\nL174:     if line:match(\"^```\") then\nL175:       -- parse language\nL176:       local lang_ = line:match(\"^```(%w+)\")\nL177:       if in_codeblock and not lang_ then\nL178:         table.insert(codeblocks, { start_line = start_line, end_line = i - 1, lang = lang })\nL179:         in_codeblock = false\nL180:       elseif lang_ then\nL181:         lang = lang_\nL182:         start_line = i - 1\nL183:         in_codeblock = true\nL184:       end\nL185:     end\nL186:   end\nL187: \nL188:   return codeblocks\nL189: end\nL190: \nL191: ---@param codeblocks table<integer, any>\nL192: local function is_cursor_in_codeblock(codeblocks)\nL193:   local cursor_pos = api.nvim_win_get_cursor(0)\nL194:   local cursor_line = cursor_pos[1] - 1 -- 转换为 0-indexed 行号\nL195: \nL196:   for _, block in ipairs(codeblocks) do\nL197:     if cursor_line >= block.start_line and cursor_line <= block.end_line then\nL198:       return block\nL199:     end\nL200:   end\nL201: \nL202:   return nil\nL203: end\nL204: \nL205: local function prepend_line_number(content)\nL206:   local lines = vim.split(content, \"\\n\")\nL207:   local result = {}\nL208:   for i, line in ipairs(lines) do\nL209:     table.insert(result, \"L\" .. i .. \": \" .. line)\nL210:   end\nL211:   return table.concat(result, \"\\n\")\nL212: end\nL213: \nL214: local function extract_code_snippets(content)\nL215:   local snippets = {}\nL216:   local current_snippet = {}\nL217:   local in_code_block = false\nL218:   local lang, start_line, end_line\nL219:   local explanation = \"\"\nL220: \nL221:   for line in content:gmatch(\"[^\\r\\n]+\") do\nL222:     local start_line_str, end_line_str = line:match(\"^Replace lines: (%d+)-(%d+)\")\nL223:     if start_line_str ~= nil and end_line_str ~= nil then\nL224:       start_line = tonumber(start_line_str)\nL225:       end_line = tonumber(end_line_str)\nL226:     end\nL227:     if line:match(\"^```\") then\nL228:       if in_code_block then\nL229:         if start_line ~= nil and end_line ~= nil then\nL230:           table.insert(snippets, {\nL231:             range = { start_line, end_line },\nL232:             content = table.concat(current_snippet, \"\\n\"),\nL233:             lang = lang,\nL234:             explanation = explanation,\nL235:           })\nL236:         end\nL237:         current_snippet = {}\nL238:         start_line, end_line = nil, nil\nL239:         explanation = \"\"\nL240:         in_code_block = false\nL241:       else\nL242:         lang = line:match(\"^```(%w+)\")\nL243:         if not lang or lang == \"\" then\nL244:           lang = \"text\"\nL245:         end\nL246:         in_code_block = true\nL247:       end\nL248:     elseif in_code_block then\nL249:       table.insert(current_snippet, line)\nL250:     else\nL251:       explanation = explanation .. line .. \"\\n\"\nL252:     end\nL253:   end\nL254: \nL255:   return snippets\nL256: end\nL257: \nL258: -- Add a new function to display notifications\nL259: local function show_notification(message)\nL260:   vim.notify(message, vim.log.levels.INFO, {\nL261:     title = \"AI Assistant\",\nL262:     timeout = 3000,\nL263:   })\nL264: end\nL265: \nL266: -- Function to get the current project root directory\nL267: local function get_project_root()\nL268:   local current_file = fn.expand(\"%:p\")\nL269:   local current_dir = fn.fnamemodify(current_file, \":h\")\nL270:   local git_root = fn.systemlist(\"git -C \" .. fn.shellescape(current_dir) .. \" rev-parse --show-toplevel\")[1]\nL271:   return git_root or current_dir\nL272: end\nL273: \nL274: ---@param sidebar avante.Sidebar\nL275: local function get_chat_history_filename(sidebar)\nL276:   local code_buf_name = api.nvim_buf_get_name(sidebar.code.buf)\nL277:   local relative_path = fn.fnamemodify(code_buf_name, \":~:.\")\nL278:   -- Replace path separators with double underscores\nL279:   local path_with_separators = fn.substitute(relative_path, \"/\", \"__\", \"g\")\nL280:   -- Replace other non-alphanumeric characters with single underscores\nL281:   return fn.substitute(path_with_separators, \"[^A-Za-z0-9._]\", \"_\", \"g\")\nL282: end\nL283: \nL284: -- Function to get the chat history file path\nL285: local function get_chat_history_file(sidebar)\nL286:   local project_root = get_project_root()\nL287:   local filename = get_chat_history_filename(sidebar)\nL288:   local history_dir = Path:new(project_root, \".avante_chat_history\")\nL289:   return history_dir:joinpath(filename .. \".json\")\nL290: end\nL291: \nL292: -- Function to get current timestamp\nL293: local function get_timestamp()\nL294:   return os.date(\"%Y-%m-%d %H:%M:%S\")\nL295: end\nL296: \nL297: -- Function to load chat history\nL298: local function load_chat_history(sidebar)\nL299:   local history_file = get_chat_history_file(sidebar)\nL300:   if history_file:exists() then\nL301:     local content = history_file:read()\nL302:     return fn.json_decode(content)\nL", "requirement": "\n\n\n\n\n\n\n\n\n\n"}, {"timestamp": "2024-08-17 14:24:32", "response": "```lua\nL1: local View = require(\"avante.view\")\nL2: \nL3: local Path = require(\"plenary.path\")\nL4: local N = require(\"nui-components\")\nL5: local Renderer = require(\"nui-components.renderer\")\nL6: local diff = require(\"avante.diff\")\nL7: local config = require(\"avante.config\")\nL8: local ai_bot = require(\"avante.ai_bot\")\nL9: local api = vim.api\nL10: local fn = vim.fn\nL11: \nL12: local CODEBLOCK_KEYBINDING_NAMESPACE = api.nvim_create_namespace(\"AVANTE_CODEBLOCK_KEYBINDING\")\nL13: local PRIORITY = vim.highlight.priorities.user\nL14: \nL15: ---@class avante.Sidebar\nL16: local Sidebar = {}\nL17: \nL18: ---@class avante.SidebarState\nL19: ---@field win integer\nL20: ---@field buf integer\nL21: \nL22: ---@class avante.Sidebar\nL23: ---@field id integer\nL24: ---@field view avante.View\nL25: ---@field code avante.SidebarState\nL26: ---@field renderer NuiRenderer\nL27: \nL28: function Sidebar:new(id)\nL29:   return setmetatable({\nL30:     id = id,\nL31:     code = { buf = 0, win = 0 },\nL32:     view = View:new(),\nL33:     renderer = nil,\nL34:   }, { __index = Sidebar })\nL35: end\nL36: \nL37: function Sidebar:destroy()\nL38:   self.view = nil\nL39:   self.code = nil\nL40:   self.renderer = nil\nL41: end\nL42: \nL43: function Sidebar:reset()\nL44:   self.code = { buf = 0, win = 0 }\nL45: end\nL46: \nL47: function Sidebar:open()\nL48:   if not self.view:is_open() then\nL49:     self:intialize()\nL50:     self:render()\nL51:   else\nL52:     self:focus()\nL53:   end\nL54:   return self\nL55: end\nL56: \nL57: function Sidebar:toggle()\nL58:   if self.view:is_open() then\nL59:     self:close()\nL60:     return false\nL61:   else\nL62:     self:open()\nL63:     return true\nL64:   end\nL65: end\nL66: \nL67: function Sidebar:has_code_win()\nL68:   return self.code.win\nL69:       and self.code.buf\nL70:       and self.code.win ~= 0\nL71:       and self.code.buf ~= 0\nL72:       and api.nvim_win_is_valid(self.code.win)\nL73:       and api.nvim_buf_is_valid(self.code.buf)\nL74: end\nL75: \nL76: function Sidebar:focus_code()\nL77:   if self:has_code_win() then\nL78:     fn.win_gotoid(self.code.win)\nL79:     return true\nL80:   end\nL81:   return false\nL82: end\nL83: \nL84: function Sidebar:focus_toggle()\nL85:   if self.view:is_open() and self:has_code_win() then\nL86:     local winid = fn.win_getid()\nL87:     if winid == self.code.win then\nL88:       fn.win_gotoid(self.view.win)\nL89:     else\nL90:       fn.win_gotoid(self.code.win)\nL91:     end\nL92:     return true\nL93:   end\nL94:   return false\nL95: end\nL96: \nL97: local get_renderer_size_and_position = function()\nL98:   local renderer_width = math.ceil(vim.o.columns * 0.3)\nL99:   local renderer_height = vim.o.lines\nL100:   local renderer_position = vim.o.columns - renderer_width\nL101:   return renderer_width, renderer_height, renderer_position\nL102: end\nL103: \nL104: function Sidebar:intialize()\nL105:   self.code.win = api.nvim_get_current_win()\nL106:   self.code.buf = api.nvim_get_current_buf()\nL107: \nL108:   local split_command = \"botright vs\"\nL109:   local renderer_width, renderer_height, renderer_position = get_renderer_size_and_position()\nL110: \nL111:   self.view:setup(split_command, renderer_width)\nL112: \nL113:   local winid = fn.bufwinid(self.view.buf)\nL114:   --- setup coord\nL115:   self.renderer = Renderer.create({\nL116:     width = api.nvim_win_get_width(winid),\nL117:     height = renderer_height,\nL118:     position = renderer_position,\nL119:     relative = { type = \"win\", winid = winid },\nL120:   })\nL121: \nL122:   -- reset states when buffer is closed\nL123:   api.nvim_buf_attach(self.code.buf, false, {\nL124:     on_detach = function(_, _)\nL125:       self:reset()\nL126:     end,\nL127:   })\nL128: end\nL129: \nL130: function Sidebar:close()\nL131:   self.renderer:close()\nL132:   fn.win_gotoid(self.code.win)\nL133: end\nL134: \nL135: ---@return boolean\nL136: function Sidebar:focus()\nL137:   if self.view:is_open() then\nL138:     fn.win_gotoid(self.view.win)\nL139:     self.renderer:focus()\nL140:     return true\nL141:   end\nL142:   return false\nL143: end\nL144: \nL145: ---@param content string\nL146: ---@param jump? boolean\nL147: function Sidebar:update_content(content, jump)\nL148:   jump = jump or false\nL149: \nL150:   vim.defer_fn(function()\nL151:     api.nvim_set_option_value(\"modifiable\", true, { buf = self.view.buf })\nL152:     api.nvim_buf_set_lines(self.view.buf, 0, -1, false, vim.split(content, \"\\n\"))\nL153:     api.nvim_set_option_value(\"modifiable\", false, { buf = self.view.buf })\nL154:     api.nvim_set_option_value(\"filetype\", \"Avante\", { buf = self.view.buf })\nL155: \nL156:     -- Move to the bottom\nL157:     if jump then\nL158:       api.nvim_win_set_cursor(self.view.win, { api.nvim_buf_line_count(self.view.buf), 0 })\nL159:       api.nvim_set_current_win(self.code.win)\nL160:     else\nL161:       self.renderer:focus()\nL162:     end\nL163:   end, 0)\nL164: end\nL165: \nL166: local function parse_codeblocks(buf)\nL167:   local codeblocks = {}\nL168:   local in_codeblock = false\nL169:   local start_line = nil\nL170:   local lang = nil\nL171: \nL172:   local lines = api.nvim_buf_get_lines(buf, 0, -1, false)\nL173:   for i, line in ipairs(lines) do\nL174:     if line:match(\"^```\") then\nL175:       -- parse language\nL176:       local lang_ = line:match(\"^```(%w+)\")\nL177:       if in_codeblock and not lang_ then\nL178:         table.insert(codeblocks, { start_line = start_line, end_line = i - 1, lang = lang })\nL179:         in_codeblock = false\nL180:       elseif lang_ then\nL181:         lang = lang_\nL182:         start_line = i - 1\nL183:         in_codeblock = true\nL184:       end\nL185:     end\nL186:   end\nL187: \nL188:   return codeblocks\nL189: end\nL190: \nL191: ---@param codeblocks table<integer, any>\nL192: local function is_cursor_in_codeblock(codeblocks)\nL193:   local cursor_pos = api.nvim_win_get_cursor(0)\nL194:   local cursor_line = cursor_pos[1] - 1 -- 转换为 0-indexed 行号\nL195: \nL196:   for _, block in ipairs(codeblocks) do\nL197:     if cursor_line >= block.start_line and cursor_line <= block.end_line then\nL198:       return block\nL199:     end\nL200:   end\nL201: \nL202:   return nil\nL203: end\nL204: \nL205: local function prepend_line_number(content)\nL206:   local lines = vim.split(content, \"\\n\")\nL207:   local result = {}\nL208:   for i, line in ipairs(lines) do\nL209:     table.insert(result, \"L\" .. i .. \": \" .. line)\nL210:   end\nL211:   return table.concat(result, \"\\n\")\nL212: end\nL213: \nL214: local function extract_code_snippets(content)\nL215:   local snippets = {}\nL216:   local current_snippet = {}\nL217:   local in_code_block = false\nL218:   local lang, start_line, end_line\nL219:   local explanation = \"\"\nL220: \nL221:   for line in content:gmatch(\"[^\\r\\n]+\") do\nL222:     local start_line_str, end_line_str = line:match(\"^Replace lines: (%d+)-(%d+)\")\nL223:     if start_line_str ~= nil and end_line_str ~= nil then\nL224:       start_line = tonumber(start_line_str)\nL225:       end_line = tonumber(end_line_str)\nL226:     end\nL227:     if line:match(\"^```\") then\nL228:       if in_code_block then\nL229:         if start_line ~= nil and end_line ~= nil then\nL230:           table.insert(snippets, {\nL231:             range = { start_line, end_line },\nL232:             content = table.concat(current_snippet, \"\\n\"),\nL233:             lang = lang,\nL234:             explanation = explanation,\nL235:           })\nL236:         end\nL237:         current_snippet = {}\nL238:         start_line, end_line = nil, nil\nL239:         explanation = \"\"\nL240:         in_code_block = false\nL241:       else\nL242:         lang = line:match(\"^```(%w+)\")\nL243:         if not lang or lang == \"\" then\nL244:           lang = \"text\"\nL245:         end\nL246:         in_code_block = true\nL247:       end\nL248:     elseif in_code_block then\nL249:       table.insert(current_snippet, line)\nL250:     else\nL251:       explanation = explanation .. line .. \"\\n\"\nL252:     end\nL253:   end\nL254: \nL255:   return snippets\nL256: end\nL257: \nL258: -- Add a new function to display notifications\nL259: local function show_notification(message)\nL260:   vim.notify(message, vim.log.levels.INFO, {\nL261:     title = \"AI Assistant\",\nL262:     timeout = 3000,\nL263:   })\nL264: end\nL265: \nL266: -- Function to get the current project root directory\nL267: local function get_project_root()\nL268:   local current_file = fn.expand(\"%:p\")\nL269:   local current_dir = fn.fnamemodify(current_file, \":h\")\nL270:   local git_root = fn.systemlist(\"git -C \" .. fn.shellescape(current_dir) .. \" rev-parse --show-toplevel\")[1]\nL271:   return git_root or current_dir\nL272: end\nL273: \nL274: ---@param sidebar avante.Sidebar\nL275: local function get_chat_history_filename(sidebar)\nL276:   local code_buf_name = api.nvim_buf_get_name(sidebar.code.buf)\nL277:   local relative_path = fn.fnamemodify(code_buf_name, \":~:.\")\nL278:   -- Replace path separators with double underscores\nL279:   local path_with_separators = fn.substitute(relative_path, \"/\", \"__\", \"g\")\nL280:   -- Replace other non-alphanumeric characters with single underscores\nL281:   return fn.substitute(path_with_separators, \"[^A-Za-z0-9._]\", \"_\", \"g\")\nL282: end\nL283: \nL284: -- Function to get the chat history file path\nL285: local function get_chat_history_file(sidebar)\nL286:   local project_root = get_project_root()\nL287:   local filename = get_chat_history_filename(sidebar)\nL288:   local history_dir = Path:new(project_root, \".avante_chat_history\")\nL289:   return history_dir:joinpath(filename .. \".json\")\nL290: end\nL291: \nL292: -- Function to get current timestamp\nL293: local function get_timestamp()\nL294:   return os.date(\"%Y-%m-%d %H:%M:%S\")\nL295: end\nL296: \nL297: -- Function to load chat history\nL298: local function load_chat_history(sidebar)\nL299:   local history_file = get_chat_history_file(sidebar)\nL300:   if history_file:exists() then\nL301:     local content = history_file:read()\nL302:     return fn.json_decode(content)\nL", "requirement": "\n\n\n\n\n\n\n\n\n"}, {"timestamp": "2024-08-17 14:24:32", "response": "```lua\nL1: local View = require(\"avante.view\")\nL2: \nL3: local Path = require(\"plenary.path\")\nL4: local N = require(\"nui-components\")\nL5: local Renderer = require(\"nui-components.renderer\")\nL6: local diff = require(\"avante.diff\")\nL7: local config = require(\"avante.config\")\nL8: local ai_bot = require(\"avante.ai_bot\")\nL9: local api = vim.api\nL10: local fn = vim.fn\nL11: \nL12: local CODEBLOCK_KEYBINDING_NAMESPACE = api.nvim_create_namespace(\"AVANTE_CODEBLOCK_KEYBINDING\")\nL13: local PRIORITY = vim.highlight.priorities.user\nL14: \nL15: ---@class avante.Sidebar\nL16: local Sidebar = {}\nL17: \nL18: ---@class avante.SidebarState\nL19: ---@field win integer\nL20: ---@field buf integer\nL21: \nL22: ---@class avante.Sidebar\nL23: ---@field id integer\nL24: ---@field view avante.View\nL25: ---@field code avante.SidebarState\nL26: ---@field renderer NuiRenderer\nL27: \nL28: function Sidebar:new(id)\nL29:   return setmetatable({\nL30:     id = id,\nL31:     code = { buf = 0, win = 0 },\nL32:     view = View:new(),\nL33:     renderer = nil,\nL34:   }, { __index = Sidebar })\nL35: end\nL36: \nL37: function Sidebar:destroy()\nL38:   self.view = nil\nL39:   self.code = nil\nL40:   self.renderer = nil\nL41: end\nL42: \nL43: function Sidebar:reset()\nL44:   self.code = { buf = 0, win = 0 }\nL45: end\nL46: \nL47: function Sidebar:open()\nL48:   if not self.view:is_open() then\nL49:     self:intialize()\nL50:     self:render()\nL51:   else\nL52:     self:focus()\nL53:   end\nL54:   return self\nL55: end\nL56: \nL57: function Sidebar:toggle()\nL58:   if self.view:is_open() then\nL59:     self:close()\nL60:     return false\nL61:   else\nL62:     self:open()\nL63:     return true\nL64:   end\nL65: end\nL66: \nL67: function Sidebar:has_code_win()\nL68:   return self.code.win\nL69:       and self.code.buf\nL70:       and self.code.win ~= 0\nL71:       and self.code.buf ~= 0\nL72:       and api.nvim_win_is_valid(self.code.win)\nL73:       and api.nvim_buf_is_valid(self.code.buf)\nL74: end\nL75: \nL76: function Sidebar:focus_code()\nL77:   if self:has_code_win() then\nL78:     fn.win_gotoid(self.code.win)\nL79:     return true\nL80:   end\nL81:   return false\nL82: end\nL83: \nL84: function Sidebar:focus_toggle()\nL85:   if self.view:is_open() and self:has_code_win() then\nL86:     local winid = fn.win_getid()\nL87:     if winid == self.code.win then\nL88:       fn.win_gotoid(self.view.win)\nL89:     else\nL90:       fn.win_gotoid(self.code.win)\nL91:     end\nL92:     return true\nL93:   end\nL94:   return false\nL95: end\nL96: \nL97: local get_renderer_size_and_position = function()\nL98:   local renderer_width = math.ceil(vim.o.columns * 0.3)\nL99:   local renderer_height = vim.o.lines\nL100:   local renderer_position = vim.o.columns - renderer_width\nL101:   return renderer_width, renderer_height, renderer_position\nL102: end\nL103: \nL104: function Sidebar:intialize()\nL105:   self.code.win = api.nvim_get_current_win()\nL106:   self.code.buf = api.nvim_get_current_buf()\nL107: \nL108:   local split_command = \"botright vs\"\nL109:   local renderer_width, renderer_height, renderer_position = get_renderer_size_and_position()\nL110: \nL111:   self.view:setup(split_command, renderer_width)\nL112: \nL113:   local winid = fn.bufwinid(self.view.buf)\nL114:   --- setup coord\nL115:   self.renderer = Renderer.create({\nL116:     width = api.nvim_win_get_width(winid),\nL117:     height = renderer_height,\nL118:     position = renderer_position,\nL119:     relative = { type = \"win\", winid = winid },\nL120:   })\nL121: \nL122:   -- reset states when buffer is closed\nL123:   api.nvim_buf_attach(self.code.buf, false, {\nL124:     on_detach = function(_, _)\nL125:       self:reset()\nL126:     end,\nL127:   })\nL128: end\nL129: \nL130: function Sidebar:close()\nL131:   self.renderer:close()\nL132:   fn.win_gotoid(self.code.win)\nL133: end\nL134: \nL135: ---@return boolean\nL136: function Sidebar:focus()\nL137:   if self.view:is_open() then\nL138:     fn.win_gotoid(self.view.win)\nL139:     self.renderer:focus()\nL140:     return true\nL141:   end\nL142:   return false\nL143: end\nL144: \nL145: ---@param content string\nL146: ---@param jump? boolean\nL147: function Sidebar:update_content(content, jump)\nL148:   jump = jump or false\nL149: \nL150:   vim.defer_fn(function()\nL151:     api.nvim_set_option_value(\"modifiable\", true, { buf = self.view.buf })\nL152:     api.nvim_buf_set_lines(self.view.buf, 0, -1, false, vim.split(content, \"\\n\"))\nL153:     api.nvim_set_option_value(\"modifiable\", false, { buf = self.view.buf })\nL154:     api.nvim_set_option_value(\"filetype\", \"Avante\", { buf = self.view.buf })\nL155: \nL156:     -- Move to the bottom\nL157:     if jump then\nL158:       api.nvim_win_set_cursor(self.view.win, { api.nvim_buf_line_count(self.view.buf), 0 })\nL159:       api.nvim_set_current_win(self.code.win)\nL160:     else\nL161:       self.renderer:focus()\nL162:     end\nL163:   end, 0)\nL164: end\nL165: \nL166: local function parse_codeblocks(buf)\nL167:   local codeblocks = {}\nL168:   local in_codeblock = false\nL169:   local start_line = nil\nL170:   local lang = nil\nL171: \nL172:   local lines = api.nvim_buf_get_lines(buf, 0, -1, false)\nL173:   for i, line in ipairs(lines) do\nL174:     if line:match(\"^```\") then\nL175:       -- parse language\nL176:       local lang_ = line:match(\"^```(%w+)\")\nL177:       if in_codeblock and not lang_ then\nL178:         table.insert(codeblocks, { start_line = start_line, end_line = i - 1, lang = lang })\nL179:         in_codeblock = false\nL180:       elseif lang_ then\nL181:         lang = lang_\nL182:         start_line = i - 1\nL183:         in_codeblock = true\nL184:       end\nL185:     end\nL186:   end\nL187: \nL188:   return codeblocks\nL189: end\nL190: \nL191: ---@param codeblocks table<integer, any>\nL192: local function is_cursor_in_codeblock(codeblocks)\nL193:   local cursor_pos = api.nvim_win_get_cursor(0)\nL194:   local cursor_line = cursor_pos[1] - 1 -- 转换为 0-indexed 行号\nL195: \nL196:   for _, block in ipairs(codeblocks) do\nL197:     if cursor_line >= block.start_line and cursor_line <= block.end_line then\nL198:       return block\nL199:     end\nL200:   end\nL201: \nL202:   return nil\nL203: end\nL204: \nL205: local function prepend_line_number(content)\nL206:   local lines = vim.split(content, \"\\n\")\nL207:   local result = {}\nL208:   for i, line in ipairs(lines) do\nL209:     table.insert(result, \"L\" .. i .. \": \" .. line)\nL210:   end\nL211:   return table.concat(result, \"\\n\")\nL212: end\nL213: \nL214: local function extract_code_snippets(content)\nL215:   local snippets = {}\nL216:   local current_snippet = {}\nL217:   local in_code_block = false\nL218:   local lang, start_line, end_line\nL219:   local explanation = \"\"\nL220: \nL221:   for line in content:gmatch(\"[^\\r\\n]+\") do\nL222:     local start_line_str, end_line_str = line:match(\"^Replace lines: (%d+)-(%d+)\")\nL223:     if start_line_str ~= nil and end_line_str ~= nil then\nL224:       start_line = tonumber(start_line_str)\nL225:       end_line = tonumber(end_line_str)\nL226:     end\nL227:     if line:match(\"^```\") then\nL228:       if in_code_block then\nL229:         if start_line ~= nil and end_line ~= nil then\nL230:           table.insert(snippets, {\nL231:             range = { start_line, end_line },\nL232:             content = table.concat(current_snippet, \"\\n\"),\nL233:             lang = lang,\nL234:             explanation = explanation,\nL235:           })\nL236:         end\nL237:         current_snippet = {}\nL238:         start_line, end_line = nil, nil\nL239:         explanation = \"\"\nL240:         in_code_block = false\nL241:       else\nL242:         lang = line:match(\"^```(%w+)\")\nL243:         if not lang or lang == \"\" then\nL244:           lang = \"text\"\nL245:         end\nL246:         in_code_block = true\nL247:       end\nL248:     elseif in_code_block then\nL249:       table.insert(current_snippet, line)\nL250:     else\nL251:       explanation = explanation .. line .. \"\\n\"\nL252:     end\nL253:   end\nL254: \nL255:   return snippets\nL256: end\nL257: \nL258: -- Add a new function to display notifications\nL259: local function show_notification(message)\nL260:   vim.notify(message, vim.log.levels.INFO, {\nL261:     title = \"AI Assistant\",\nL262:     timeout = 3000,\nL263:   })\nL264: end\nL265: \nL266: -- Function to get the current project root directory\nL267: local function get_project_root()\nL268:   local current_file = fn.expand(\"%:p\")\nL269:   local current_dir = fn.fnamemodify(current_file, \":h\")\nL270:   local git_root = fn.systemlist(\"git -C \" .. fn.shellescape(current_dir) .. \" rev-parse --show-toplevel\")[1]\nL271:   return git_root or current_dir\nL272: end\nL273: \nL274: ---@param sidebar avante.Sidebar\nL275: local function get_chat_history_filename(sidebar)\nL276:   local code_buf_name = api.nvim_buf_get_name(sidebar.code.buf)\nL277:   local relative_path = fn.fnamemodify(code_buf_name, \":~:.\")\nL278:   -- Replace path separators with double underscores\nL279:   local path_with_separators = fn.substitute(relative_path, \"/\", \"__\", \"g\")\nL280:   -- Replace other non-alphanumeric characters with single underscores\nL281:   return fn.substitute(path_with_separators, \"[^A-Za-z0-9._]\", \"_\", \"g\")\nL282: end\nL283: \nL284: -- Function to get the chat history file path\nL285: local function get_chat_history_file(sidebar)\nL286:   local project_root = get_project_root()\nL287:   local filename = get_chat_history_filename(sidebar)\nL288:   local history_dir = Path:new(project_root, \".avante_chat_history\")\nL289:   return history_dir:joinpath(filename .. \".json\")\nL290: end\nL291: \nL292: -- Function to get current timestamp\nL293: local function get_timestamp()\nL294:   return os.date(\"%Y-%m-%d %H:%M:%S\")\nL295: end\nL296: \nL297: -- Function to load chat history\nL298: local function load_chat_history(sidebar)\nL299:   local history_file = get_chat_history_file(sidebar)\nL300:   if history_file:exists() then\nL301:     local content = history_file:read()\nL302:     return fn.json_decode(content)\nL", "requirement": "\n\n\n\n\n\n\n\n\n\n\n\n"}, {"timestamp": "2024-08-17 14:24:38", "response": "```lua\nL1: local View = require(\"avante.view\")\nL2: \nL3: local Path = require(\"plenary.path\")\nL4: local N = require(\"nui-components\")\nL5: local Renderer = require(\"nui-components.renderer\")\nL6: local diff = require(\"avante.diff\")\nL7: local config = require(\"avante.config\")\nL8: local ai_bot = require(\"avante.ai_bot\")\nL9: local api = vim.api\nL10: local fn = vim.fn\nL11: \nL12: local CODEBLOCK_KEYBINDING_NAMESPACE = api.nvim_create_namespace(\"AVANTE_CODEBLOCK_KEYBINDING\")\nL13: local PRIORITY = vim.highlight.priorities.user\nL14: \nL15: ---@class avante.Sidebar\nL16: local Sidebar = {}\nL17: \nL18: ---@class avante.SidebarState\nL19: ---@field win integer\nL20: ---@field buf integer\nL21: \nL22: ---@class avante.Sidebar\nL23: ---@field id integer\nL24: ---@field view avante.View\nL25: ---@field code avante.SidebarState\nL26: ---@field renderer NuiRenderer\nL27: \nL28: function Sidebar:new(id)\nL29:   return setmetatable({\nL30:     id = id,\nL31:     code = { buf = 0, win = 0 },\nL32:     view = View:new(),\nL33:     renderer = nil,\nL34:   }, { __index = Sidebar })\nL35: end\nL36: \nL37: function Sidebar:destroy()\nL38:   self.view = nil\nL39:   self.code = nil\nL40:   self.renderer = nil\nL41: end\nL42: \nL43: function Sidebar:reset()\nL44:   self.code = { buf = 0, win = 0 }\nL45: end\nL46: \nL47: function Sidebar:open()\nL48:   if not self.view:is_open() then\nL49:     self:intialize()\nL50:     self:render()\nL51:   else\nL52:     self:focus()\nL53:   end\nL54:   return self\nL55: end\nL56: \nL57: function Sidebar:toggle()\nL58:   if self.view:is_open() then\nL59:     self:close()\nL60:     return false\nL61:   else\nL62:     self:open()\nL63:     return true\nL64:   end\nL65: end\nL66: \nL67: function Sidebar:has_code_win()\nL68:   return self.code.win\nL69:       and self.code.buf\nL70:       and self.code.win ~= 0\nL71:       and self.code.buf ~= 0\nL72:       and api.nvim_win_is_valid(self.code.win)\nL73:       and api.nvim_buf_is_valid(self.code.buf)\nL74: end\nL75: \nL76: function Sidebar:focus_code()\nL77:   if self:has_code_win() then\nL78:     fn.win_gotoid(self.code.win)\nL79:     return true\nL80:   end\nL81:   return false\nL82: end\nL83: \nL84: function Sidebar:focus_toggle()\nL85:   if self.view:is_open() and self:has_code_win() then\nL86:     local winid = fn.win_getid()\nL87:     if winid == self.code.win then\nL88:       fn.win_gotoid(self.view.win)\nL89:     else\nL90:       fn.win_gotoid(self.code.win)\nL91:     end\nL92:     return true\nL93:   end\nL94:   return false\nL95: end\nL96: \nL97: local get_renderer_size_and_position = function()\nL98:   local renderer_width = math.ceil(vim.o.columns * 0.3)\nL99:   local renderer_height = vim.o.lines\nL100:   local renderer_position = vim.o.columns - renderer_width\nL101:   return renderer_width, renderer_height, renderer_position\nL102: end\nL103: \nL104: function Sidebar:intialize()\nL105:   self.code.win = api.nvim_get_current_win()\nL106:   self.code.buf = api.nvim_get_current_buf()\nL107: \nL108:   local split_command = \"botright vs\"\nL109:   local renderer_width, renderer_height, renderer_position = get_renderer_size_and_position()\nL110: \nL111:   self.view:setup(split_command, renderer_width)\nL112: \nL113:   local winid = fn.bufwinid(self.view.buf)\nL114:   --- setup coord\nL115:   self.renderer = Renderer.create({\nL116:     width = api.nvim_win_get_width(winid),\nL117:     height = renderer_height,\nL118:     position = renderer_position,\nL119:     relative = { type = \"win\", winid = winid },\nL120:   })\nL121: \nL122:   -- reset states when buffer is closed\nL123:   api.nvim_buf_attach(self.code.buf, false, {\nL124:     on_detach = function(_, _)\nL125:       self:reset()\nL126:     end,\nL127:   })\nL128: end\nL129: \nL130: function Sidebar:close()\nL131:   self.renderer:close()\nL132:   fn.win_gotoid(self.code.win)\nL133: end\nL134: \nL135: ---@return boolean\nL136: function Sidebar:focus()\nL137:   if self.view:is_open() then\nL138:     fn.win_gotoid(self.view.win)\nL139:     self.renderer:focus()\nL140:     return true\nL141:   end\nL142:   return false\nL143: end\nL144: \nL145: ---@param content string\nL146: ---@param jump? boolean\nL147: function Sidebar:update_content(content, jump)\nL148:   jump = jump or false\nL149: \nL150:   vim.defer_fn(function()\nL151:     api.nvim_set_option_value(\"modifiable\", true, { buf = self.view.buf })\nL152:     api.nvim_buf_set_lines(self.view.buf, 0, -1, false, vim.split(content, \"\\n\"))\nL153:     api.nvim_set_option_value(\"modifiable\", false, { buf = self.view.buf })\nL154:     api.nvim_set_option_value(\"filetype\", \"Avante\", { buf = self.view.buf })\nL155: \nL156:     -- Move to the bottom\nL157:     if jump then\nL158:       api.nvim_win_set_cursor(self.view.win, { api.nvim_buf_line_count(self.view.buf), 0 })\nL159:       api.nvim_set_current_win(self.code.win)\nL160:     else\nL161:       self.renderer:focus()\nL162:     end\nL163:   end, 0)\nL164: end\nL165: \nL166: local function parse_codeblocks(buf)\nL167:   local codeblocks = {}\nL168:   local in_codeblock = false\nL169:   local start_line = nil\nL170:   local lang = nil\nL171: \nL172:   local lines = api.nvim_buf_get_lines(buf, 0, -1, false)\nL173:   for i, line in ipairs(lines) do\nL174:     if line:match(\"^```\") then\nL175:       -- parse language\nL176:       local lang_ = line:match(\"^```(%w+)\")\nL177:       if in_codeblock and not lang_ then\nL178:         table.insert(codeblocks, { start_line = start_line, end_line = i - 1, lang = lang })\nL179:         in_codeblock = false\nL180:       elseif lang_ then\nL181:         lang = lang_\nL182:         start_line = i - 1\nL183:         in_codeblock = true\nL184:       end\nL185:     end\nL186:   end\nL187: \nL188:   return codeblocks\nL189: end\nL190: \nL191: ---@param codeblocks table<integer, any>\nL192: local function is_cursor_in_codeblock(codeblocks)\nL193:   local cursor_pos = api.nvim_win_get_cursor(0)\nL194:   local cursor_line = cursor_pos[1] - 1 -- 转换为 0-indexed 行号\nL195: \nL196:   for _, block in ipairs(codeblocks) do\nL197:     if cursor_line >= block.start_line and cursor_line <= block.end_line then\nL198:       return block\nL199:     end\nL200:   end\nL201: \nL202:   return nil\nL203: end\nL204: \nL205: local function prepend_line_number(content)\nL206:   local lines = vim.split(content, \"\\n\")\nL207:   local result = {}\nL208:   for i, line in ipairs(lines) do\nL209:     table.insert(result, \"L\" .. i .. \": \" .. line)\nL210:   end\nL211:   return table.concat(result, \"\\n\")\nL212: end\nL213: \nL214: local function extract_code_snippets(content)\nL215:   local snippets = {}\nL216:   local current_snippet = {}\nL217:   local in_code_block = false\nL218:   local lang, start_line, end_line\nL219:   local explanation = \"\"\nL220: \nL221:   for line in content:gmatch(\"[^\\r\\n]+\") do\nL222:     local start_line_str, end_line_str = line:match(\"^Replace lines: (%d+)-(%d+)\")\nL223:     if start_line_str ~= nil and end_line_str ~= nil then\nL224:       start_line = tonumber(start_line_str)\nL225:       end_line = tonumber(end_line_str)\nL226:     end\nL227:     if line:match(\"^```\") then\nL228:       if in_code_block then\nL229:         if start_line ~= nil and end_line ~= nil then\nL230:           table.insert(snippets, {\nL231:             range = { start_line, end_line },\nL232:             content = table.concat(current_snippet, \"\\n\"),\nL233:             lang = lang,\nL234:             explanation = explanation,\nL235:           })\nL236:         end\nL237:         current_snippet = {}\nL238:         start_line, end_line = nil, nil\nL239:         explanation = \"\"\nL240:         in_code_block = false\nL241:       else\nL242:         lang = line:match(\"^```(%w+)\")\nL243:         if not lang or lang == \"\" then\nL244:           lang = \"text\"\nL245:         end\nL246:         in_code_block = true\nL247:       end\nL248:     elseif in_code_block then\nL249:       table.insert(current_snippet, line)\nL250:     else\nL251:       explanation = explanation .. line .. \"\\n\"\nL252:     end\nL253:   end\nL254: \nL255:   return snippets\nL256: end\nL257: \nL258: -- Add a new function to display notifications\nL259: local function show_notification(message)\nL260:   vim.notify(message, vim.log.levels.INFO, {\nL261:     title = \"AI Assistant\",\nL262:     timeout = 3000,\nL263:   })\nL264: end\nL265: \nL266: -- Function to get the current project root directory\nL267: local function get_project_root()\nL268:   local current_file = fn.expand(\"%:p\")\nL269:   local current_dir = fn.fnamemodify(current_file, \":h\")\nL270:   local git_root = fn.systemlist(\"git -C \" .. fn.shellescape(current_dir) .. \" rev-parse --show-toplevel\")[1]\nL271:   return git_root or current_dir\nL272: end\nL273: \nL274: ---@param sidebar avante.Sidebar\nL275: local function get_chat_history_filename(sidebar)\nL276:   local code_buf_name = api.nvim_buf_get_name(sidebar.code.buf)\nL277:   local relative_path = fn.fnamemodify(code_buf_name, \":~:.\")\nL278:   -- Replace path separators with double underscores\nL279:   local path_with_separators = fn.substitute(relative_path, \"/\", \"__\", \"g\")\nL280:   -- Replace other non-alphanumeric characters with single underscores\nL281:   return fn.substitute(path_with_separators, \"[^A-Za-z0-9._]\", \"_\", \"g\")\nL282: end\nL283: \nL284: -- Function to get the chat history file path\nL285: local function get_chat_history_file(sidebar)\nL286:   local project_root = get_project_root()\nL287:   local filename = get_chat_history_filename(sidebar)\nL288:   local history_dir = Path:new(project_root, \".avante_chat_history\")\nL289:   return history_dir:joinpath(filename .. \".json\")\nL290: end\nL291: \nL292: -- Function to get current timestamp\nL293: local function get_timestamp()\nL294:   return os.date(\"%Y-%m-%d %H:%M:%S\")\nL295: end\nL296: \nL297: -- Function to load chat history\nL298: local function load_chat_history(sidebar)\nL299:   local history_file = get_chat_history_file(sidebar)\nL300:   if history_file:exists() then\nL301:     local content = history_file:read()\nL302:     return fn.json_decode(content)\nL", "requirement": "\n\n\n\n\n\n\n\n\n\n\n\nk"}]